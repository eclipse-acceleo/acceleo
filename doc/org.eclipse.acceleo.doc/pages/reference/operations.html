<!DOCTYPE html>
<html lang="en">
<!--
/********************************************************************************
** Copyright (c) 2012 Obeo.
** All rights reserved. This program and the accompanying materials
** are made available under the terms of the Eclipse Public License v1.0
** which accompanies this distribution, and is available at
** http://www.eclipse.org/legal/epl-v10.html
**
** Contributors:
**    Stephane Begaudeau (Obeo) - initial API and implementation
*********************************************************************************/
-->
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="St&eacute;phane B&eacute;gaudeau">    

    <!-- IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <link href="../../assets/css/bootstrap.css" rel="stylesheet">
    <link href="../../assets/css/docs.css" rel="stylesheet">
    
    <title>Acceleo</title>
  </head>
  <body>
    <div class="container">
      <header class="jumbotron subhead" id="overview">
        <h1>Operations</h1>
        <p class="lead">All the operations available in the Acceleo language</p>
        <!--<div class="subnav">
          <ul class="nav nav-pills">
            <li><a href="#oclany">OclAny</a></li>
            <li><a href="#string">String</a></li>
            <li><a href="#number">Number</a></li>
            <li><a href="#boolean">Boolean</a></li>
            <li><a href="#collections">Collections</a></li>
            <li><a href="#sequence">Sequence</a></li>
            <li><a href="#orderedset">Ordered Set</a></li>
            <li><a href="#set">Set</a></li>
            <li><a href="#bag">Bag</a></li>
          </ul>
        </div>-->
      </header>
      
      <section id="example">
        <p>
          Some example requires an example model, thus we will use the following model as an example.
        </p>
        <img src="../../assets/img/reference/package.png" />
      </section>
      
      <section id="oclany">
        <div class="page-header">
          <h1>OclAny <small>operations available on all model objects.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>= (elem: OclAny): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt; (elem: OclAny): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt; (elem: T): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&gt; (elem: T): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;= (elem: T): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&gt;= (elem: T): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>ancestors(): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>ancestors(oclType: OclType): Sequence(OclType)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eAllContents(): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eAllContents(oclType: OclType): Sequence(OclType)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>current(index: Integer): OclAny</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>current(oclType: OclType): OclType</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eContainer(oclType: OclType): OclType</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eContents(oclType: OclType): Sequence(OclType)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eGet(featureName: String): OclAny</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eInverse(): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>eInverse(oclType: OclType): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>followingSiblings(): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>followingSiblings(oclType: OclType): Sequence(OclType)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>getProperty(key: String): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>getProperty(key: String, parameters: Sequence(OclAny)): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>getProperty(name:String, key: String): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>getProperty(name: String, key: String, parameters: Sequence(OclAny)): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>invoke(className: String, methodName: String, arguments: Sequence(OclAny)): OclAny</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lineSeparator(): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>oclAsType(oclType: OclType): OclType</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>oclIsInvalid(): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>oclIsKindOf(oclType: OclType): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>oclIsTypeOf(oclType: OclType): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>oclIsUndefined(): Boolean</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>precedindSiblings(): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>precedingSiblings(oclType: OclType): Sequence(OclType)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>siblings(): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>siblings(oclType: OclType): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>toString(): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>+ (str: String): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>= (elem: OclAny): Boolean</h2>
        <p>
          Returns true if self is equal to object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['first string' = 'first string'/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['first string' = Sequence{'a', 'b'}/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>&lt;&gt; (elem: OclAny): Boolean</h2>
        <p>
          Returns false if self is equal to object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['first string' &lt;&gt; 'first string'/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>['first string' &lt;&gt; Sequence{'a', 'b'}/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>&lt; (elem: T): Boolean</h2>
        <p>
          Returns true if self is comparable to object and less than object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['first string' &lt; 'second string'/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['first string' &lt; 'another string'/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>&gt; (elem: T): Boolean</h2>
        <p>
          Returns true if self is comparable to object and greater than object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['first string' &gt; 'second string'/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>['first string' &gt; 'another string'/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>&lt;= (elem: OclAny): Boolean</h2>
        <p>
          Returns true if self is comparable to object and less than or equal to object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['first string' &lt;= 'second string'/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['first string' &lt;= 'first string'/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['first string' &lt;= 'another string'/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>&gt;= (elem: OclAny): Boolean</h2>
        <p>
          Returns true if self is comparable to object and greater than or equal to object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['first string' &gt;= 'second string'/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>['first string' &gt;= 'first string'/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['first string' &gt;= 'another string'/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>ancestors(): Sequence(OclAny)</h2>
        <p>
          Returns a Sequence containing the full set of the receiver's ancestors.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.ancestors()/]</td>
              <td>Sequence{First Child Package, Root Package}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>ancestors(oclType: OclType): Sequence(OclAny)</h2>
        <p>
          Returns the elements of the given type from the set of the receiver's ancestors as a Sequence.
          The returned sequence's elements are typed with the expected type (so there's no need to invoke
          oclAsType(oclType) on the sequence or its elements). In this example, the element root is also
          returned because Model is an instance of Package. All the element returned are ancestors for
          which oclIsKindOf(oclType) returns true.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.ancestors(EPackage)/]</td>
              <td>Sequence{First Child Package, Root Package}</td>
            </tr>
            <tr>
              <td>[elementOne.ancestors(EClass)/]</td>
              <td>Sequence{}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>eAllContents(): Sequence(OclAny)</h2>
        <p>
          Returns the whole content tree of the receiver as a Sequence.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[rootPackage.eAllContents()/]</td>
              <td>Sequence{First Child Package, Element One, Element Two, Second Child Package, Third Child Package, Element Three, Element Four, Element Five}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>eAllContents(oclType: OclType): Sequence(OclAny)</h2>
        <p>
          Returns the elements of the given type from the whole content tree of the receiver as a Sequence.
          The returned sequence's elements are typed with the expected type (so there's no need to invoke
          oclAsType(oclType) on the sequence or its elements).
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[rootPackage.eAllContents(EClass)/]</td>
              <td>Sequence{Element One, Element Two, Element Three, Element Four, Element Five}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>current(index: Integer): OclAny</h2>
        <p>
          Returns the value of the context index ranks above the current context.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>
                [for (anEPackage: EPackage | self.eSubpackages)]<br />
[for (anEClass: EClass | anEPackage.eClassifiers->filter(EClass))]<br />
[current(0)/]<br />
[current(1)/]<br />
[current(2)/]<br />
[/for]<br />
[/for]<br />
              </td>
              <td>
                The expression "current(0)" returns self, in this case the current value of "anEClass".<br />
                The expression "current(1)" returns the current value of "anEPackage".<br />
                The expression "current(2)" returns the value of "self" before the first block "for".<br />
              </td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>current(oclType: OclType): OclType</h2>
        <p>
          This will have the same effect as current(Integer) except that is will return the
          first context (self variable) of the given type, at or above the current one.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>
                [for (anEPackage: EPackage | self.eSubpackages)]<br />
[for (anEClass: EClass | anEPackage.eClassifiers->filter(EClass))]<br />
[current(EClass)/]<br />
[current(EPackage)/]<br />
[/for]<br />
[/for]<br />
              </td>
              <td>
                The expression "current(EClass)" returns the current value of "anEClass".<br />
                The expression "current(EPackage)" returns the current value of "anEPackage".<br />
              </td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>eContainer(oclType: OclType): OclType</h2>
        <p>
          Returns the first ancestor of the given type, i.e. the first ancestor for which
          oclIsKindOf(oclType) evaluates to true. The returned element is typed with the
          expected type (so there's no need to invoke oclAsType(oclType) on it).
        </p>
        <p>
          Important: users of Acceleo 2.x should note that, contrary to what took place in
          acceleo 2.x, this operation never returns self even when self.oclIsKindOf(oclType) is true.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.eContainer(EPackage)/]</td>
              <td>First Child Package</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>eContents(oclType: OclType): Sequence(OclType)</h2>
        <p>
          Returns a sequence of the direct children of self that are of the given type, i.e. the direct
          children for which oclIsKindOf(oclType) evaluates to true. The returned sequence's elements
          are typed with the expected type (so there's no need to invoke oclAsType(oclType) on the
          sequence or its elements).
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[firstChildPackage.eContents(EClass)/]</td>
              <td>Sequence{Element One, Element Two}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>eGet(featureName: String): OclAny</h2>
        <p>
          This will fetch the value of the feature named featureName on the current Object. Return
          type can as well be a collection as a single value.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementFive.eGet('link')/]</td>
              <td>Element Four</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>eInverse(): Sequence(OclAny)</h2>
        <p>
          Returns the sequence of all objects referencing self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementFour.eInverse()/]</td>
              <td>Sequence{Second Child Package, Element Five}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>eInverse(oclType: OclType): Sequence(OclAny)</h2>
        <p>
          Returns the elements of the given type from the set of the inverse references of self. The
          returned sequence's elements are typed with the expected type (so there's no need to invoke
          oclAsType(oclType) on the sequence or its elements).
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementFour.eInverse(EClass)/]</td>
              <td>Sequence{Element Five}</td>
            </tr>
            <tr>
              <td>[elementFour.eInverse(EPackage)/]</td>
              <td>Sequence{}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>followingSiblings(): Sequence(OclAny)</h2>
        <p>
          Returns a Sequence containing the full set of the receiver's following siblings.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[thirdChildPackage.followingSiblings()/]</td>
              <td>Sequence{Element Four, Element Five}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>followingSiblings(oclType: OclType): Sequence(OclType)</h2>
        <p>
          Returns the elements of the given type from the set of the receiver's following siblings
          as a Sequence. The returned sequence's elements are typed with the expected type (so
          there's no need to invoke oclAsType(oclType) on the sequence or its elements).
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[thirdChildPackage.followingSiblings(EClass)/]</td>
              <td>Sequence{Element Four, Element Five}</td>
            </tr>
            <tr>
              <td>[thirdChildPackage.followingSiblings(EPackage)/]</td>
              <td>Sequence{}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>getProperty(key: String): String</h2>
        <p>
          Returns the value of the property corresponding to the given key. Note that parameterized
          properties will be returned "as is" by this operation (parameters are not processed).
        </p>
        <p>
          We are considering two files, a.properties containing:
        </p>
        <ul>
          <li>a.b.c = This is a parameterized property: {0}</li>
        </ul>
        <p>
          And b.properties containing:
        </p>
        <ul>
          <li>a.b.c = This is a parameterized property with a name conflict: {0}</li>
          <li>a.b.c.d = This is a standard property</li>
        </ul>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[getProperty('a.b.c')/]</td>
              <td>'This is a parameterized property: {0}'</td>
            </tr>
            <tr>
              <td>[getProperty('a.b.c.d')/]</td>
              <td>'This is a standard property'</td>
            </tr>
            <tr>
              <td>[getProperty('a.b.c.d.e')/]</td>
              <td>''</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>getProperty(key: String, parameters: Sequence(OclAny)): String</h2>
        <p>
          Returns the value of the property corresponding to the given key, with its parameters
          substituted with the given values if any.
        </p>
        <p>
          We are considering two files, a.properties containing:
        </p>
        <ul>
          <li>a.b.c = This is a parameterized property: {0}</li>
        </ul>
        <p>
          And b.properties containing:
        </p>
        <ul>
          <li>a.b.c = This is a parameterized property with a name conflict: {0}</li>
          <li>a.b.c.d = This is a standard property</li>
        </ul>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[getProperty('a.b.c', Sequence{'substitution'})/]</td>
              <td>'This is a parameterized property: substitution'</td>
            </tr>
            <tr>
              <td>[getProperty('a.b.c', Sequence{'substitution'})/]</td>
              <td>'This is a parameterized property: {0}'</td>
            </tr>
            <tr>
              <td>[getProperty('a.b.c.d', Sequence{'substitution'})/]</td>
              <td>'This is a standard property'</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>getProperty(name:String, key: String): String</h2>
        <p>
          Returns the value of the property corresponding to the given key from a properties file
          corresponding to the given name. Note that parameterized properties will be returned as
          is with this.
        </p>
        <p>
          We are considering two files, a.properties containing:
        </p>
        <ul>
          <li>a.b.c = This is a parameterized property: {0}</li>
        </ul>
        <p>
          And b.properties containing:
        </p>
        <ul>
          <li>a.b.c = This is a parameterized property with a name conflict: {0}</li>
          <li>a.b.c.d = This is a standard property</li>
        </ul>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[getProperty('b.properties', 'a.b.c')/]</td>
              <td>'Parameterized property with a name conflict: {0}'</td>
            </tr>
            <tr>
              <td>[getProperty('a.properties', 'a.b.c.d')/]</td>
              <td>''</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>getProperty(name: String, key: String, parameters: Sequence(OclAny)): String</h2>
        <p>
          Returns the value of the property corresponding to the given key from a properties file
          corresponding to the given name, with its parameters substituted with the given values if any.
        </p>
        <p>
          We are considering two files, a.properties containing:
        </p>
        <ul>
          <li>a.b.c = This is a parameterized property: {0}</li>
        </ul>
        <p>
          And b.properties containing:
        </p>
        <ul>
          <li>a.b.c = This is a parameterized property with a name conflict: {0}</li>
          <li>a.b.c.d = This is a standard property</li>
        </ul>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[getProperty('b.properties', 'a.b.c', Sequence{'substitution'})/]</td>
              <td>'Parameterized property with a name conflict: substitution'</td>
            </tr>
            <tr>
              <td>[getProperty('b.properties', 'a.b.c', Sequence{})/]</td>
              <td>'Parameterized property with a name conflict: {0}'</td>
            </tr>
            <tr>
              <td>[getProperty('a.properties', 'a.b.c.d', Sequence{'substitution'})/]</td>
              <td>''</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>invoke(className: String, methodName: String, arguments: Sequence(OclAny)): OclAny</h2>
        <p>
          Invokes the Java method method of class class with the given arguments. This will return
          OclInvalid if the method cannot be called in any way (bad arguments, mispelled name, mispelled
          signature, encapsulation errors, ...). This is only intended to be used to call Java methods
          for now.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[invoke('java.lang.String', 'toUpperCase()', Sequence{elementOne.name})/]</td>
              <td>ELEMENT ONE</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>lineSeparator(): String</h2>
        <p>
          Returns the line separator of the current platform (similar to System.getProperty('line.separator'))
          or the line separator of the Eclipse properties if it has been changed by the user.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[lineSeparator()/]</td>
              <td>'\n' (Unix) or '\r\n' (Dos) or '\r' (Mac Os Classic)</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>oclAsType(oclType: OclType): OclType</h2>
        <p>
          Returns self statically typed as typespec if it is an instance of this type. Note that this
          does not alter the runtime value of self, it only enables access to subtype operations. This
          operation allows users to cast self to another type.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclAsType(EClass)/]</td>
              <td>Element One</td>
            </tr>
            <tr>
              <td>[elementOne.oclAsType(EPackage)/]</td>
              <td>Invalid</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>oclIsInvalid(): Boolean</h2>
        <p>
          Returns true if self is equal to invalid.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclIsInvalid()/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>oclIsKindOf(oclType: OclType): Boolean</h2>
        <p>
          Returns true if the type of self corresponds to the type or supertype of typespec, false
          otherwise. This operation allows users to check the class hierarchy of self much like
          would an instanceof Java.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclIsKindOf(EClass)/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>[elementOne.oclIsKindOf(ENamedElement)/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>oclIsTypeOf(oclType: OclType): Boolean</h2>
        <p>
          Returns true if the type of self is the same as typespec, or false otherwise. This
          operation allows users to check the exact class type of self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclIsTypeOf(EClass)/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>[elementOne.oclIsTypeOf(ENamedElement)/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>oclIsUndefined(): Boolean</h2>
        <p>
          Returns true if self is equal to invalid or null.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.oclIsUndefined()/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>precedindSiblings(): Sequence(OclAny)</h2>
        <p>
          Returns a Sequence containing the full set of the receiver's preceding siblings.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementFive.precedingSiblings()/]</td>
              <td>Sequence{Third Child Package, Element Four}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>precedingSiblings(oclType: OclType): Sequence(OclType)</h2>
        <p>
          Returns the elements of the given type from the set of the receiver's preceding siblings as
          a Sequence. The returned sequence's elements are typed with the expected type (so there's
          no need to invoke oclAsType(oclType) on the sequence or its elements).
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementFive.precedingSiblings(EPackage)/]</td>
              <td>Sequence{Third Child Package}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>siblings(): Sequence(OclAny)</h2>
        <p>
          Returns a Sequence containing the full set of the receiver's siblings.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementFour.siblings()/]</td>
              <td>Sequence{Third Child Package, Element Five}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>siblings(oclType: OclType): Sequence(OclAny)</h2>
        <p>
          Returns the elements of the given type from the set of the receiver's siblings as a Sequence.
          The returned sequence's elements are typed with the expected type (so there's no need to
          invoke oclAsType(oclType) on the sequence or its elements).
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementFour.siblings(EPackage)/]</td>
              <td>Sequence{Third Child Package}</td>
            </tr>
            <tr>
              <td>[elementFour.siblings(EClass)/]</td>
              <td>Sequence{Element Five}</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>toString(): String</h2>
        <p>
          Returns the String representation of the receiver.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne.toString()/]</td>
              <td>org.eclipse.emf.ecore.impl.EClassImpl@4d06b4 (name: Element One) (instanceClassName: null) (abstract: false, interface: false)</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        
        <hr />
        
        <h2>+ (str: String): String</h2>
        <p>
          Returns the string representation of the receiver concatenated with the given string.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[elementOne + 'a'/]</td>
              <td>org.eclipse.emf.ecore.impl.EClassImpl@4d06b4 (name: Element One) (instanceClassName: null) (abstract: false, interface: false)a</td>
            </tr>
          </tbody>
        </table>
        <a href="#oclany">back to section</a>
        <br />
        <br />
      </section>
      
      <section id="string">
        <div class="page-header">
          <h1>String <small>operations available on strings.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>concat(str: String): String</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>contains(subString: String): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith(subString: String): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>equalsIgnoreCase(str: String): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo standard">
              <td>first(n: Integer): String</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>index(subString: String): Integer</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>index(subString: String, index: Integer): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo standard">
              <td>isAlpha(): Boolean</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>isAlphanum(): Boolean</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>last(n: Integer): String</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndex(subString: String): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndex(subString: String, index: Integer): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>matches(regex: String): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>prefix(str: String): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>replace(subStringRegex: String, replacementRegex: String): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>replaceAll(subStringRegex: String, replacementRegex: String): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>size(): Integer</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith(subString: String): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo standard">
              <td>strcmp(str: String): Integer</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>strstr(str: String): Boolean</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>strtok(str: String, n: Integer): String</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>substitute(origin: String, replacement: String): String</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>substituteAll(origin: String, replacement: String): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>substring(start: Integer): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>substring(start: Integer, end: Integer): String</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>toInteger(): Integer</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>tokenize(): Sequence(String)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>tokenize(subString: String): Sequence(String)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>tokenizeLine(): Sequence(String)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>toLower(): String</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>toLowerFirst(): String</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>toReal(): Real</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo standard">
              <td>toUpperFirst(): String</td>
              <td>Acceleo</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>toUpper(): String</td>
              <td>Ocl</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>trim(): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>+ (str: String): String</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>concat(str: String): String</h2>
        <p>
          Returns a string containing "<i>self</i>" followed by "<i>str</i>".
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.concat('anotherString')/]</td>
              <td>'aStringanotherString'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>contains(subString: String): Boolean</h2>
        <p>
          Returns "<i>true</i>" if "<i>self</i>" contains the string "<i>subString</i>", "<i>false</i>" otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.contains('String')/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['aString'.contains('anotherString')/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>['aString'.contains('string')/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>endsWith(subString: String): Boolean</h2>
        <p>
          Returns "<i>true</i>" if "<i>self</i>" ends with the string "<i>subString</i>", "<i>false</i>" otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.endsWith('String')/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['aString'.endsWith('anotherString')/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>['aString'.endsWith('string')/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>equalsIgnoreCase(str: String): Boolean</h2>
        <p>
          Returns "<i>true</i>" if "<i>self</i>" is equal to the string "<i>str</i>" ignoring case considerations, otherwise
          returns "<i>false</i>". Two strings are considered equal ignoring the case if they are of the same length
          and corresponding characters in the two strings are equal ignoring their case.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.equalsIgnoreCase('anotherString')/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>['aString'.equalsIgnoreCase('aString')/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['aString'.equalsIgnoreCase('astring')/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>first(n: Integer): String</h2>
        <p>
          Returns the first "<i>n</i>" characters of "<i>self</i>", or "<i>self</i>" if its size is less than "<i>n</i>".
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.first(2)/]</td>
              <td>'aS'</td>
            </tr>
            <tr>
              <td>['aString'.first(0)/]</td>
              <td>''</td>
            </tr>
            <tr>
              <td>['aString'.first(-1)/]</td>
              <td><i>Invalid</i></td>
            </tr>
            <tr>
              <td>['aString'.first(15)/]</td>
              <td>'aString'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>index(subString: String): Integer</h2>
        <p>
          Returns the index of the string "<i>subString</i>" in "<i>self</i>", or "<i>-1</i>" if "<i>self</i>" contains no occurrence of 
          "<i>subString</i>".
          Important: String indexes start at 1. Consequently the last character's index in a string
          is equal to the string's length.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.index('a')/]</td>
              <td>1</td>
            </tr>
            <tr>
              <td>['aString'.index('String')/]</td>
              <td>2</td>
            </tr>
            <tr>
              <td>['aString'.index('Yop')/]</td>
              <td>-1</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>index(subString: String, index: Integer): Integer</h2>
        <p>
          Returns the index of the string "<i>subString</i>" in "<i>self</i>", or "<i>-1</i>" if "<i>self</i>" contains no occurrence
          of "<i>subString</i>" starting from the given "<i>index</i>".
          Important: String indexes start at 1. Consequently the last character's index in a string is equal to the string's length.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.index('a', 1)/]</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>['aString'.index('a', 0)/]</td>
              <td>1</td>
            </tr>
            <tr>
              <td>['aString'.index('String', -1)/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>isAlpha(): Boolean</h2>
        <p>
          Returns "<i>true</i>" if "<i>self</i>" consists only of alphabetical characters, "<i>false</i>" otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.isAlpha()/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['aString1'.isAlpha()/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>isAlphanum(): Boolean</h2>
        <p>
          Returns "<i>true</i>" if "<i>self</i>" consists only of alphanumeric characters, "<i>false</i>" otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.isAlphanum()/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['aString1'.isAlphanum()/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>last(n: Integer): String</h2>
        <p>
          Returns the last "<i>n</i>" characters of "<i>self</i>", or "<i>self</i>" if its size is less than "<i>n</i>".
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.last(1)/]</td>
              <td>'g'</td>
            </tr>
            <tr>
              <td>['aString'.last(0)/]</td>
              <td>''</td>
            </tr>
            <tr>
              <td>['aString'.last(15)/]</td>
              <td>'aString'</td>
            </tr>
            <tr>
              <td>['aString'.last(-1)/]</td>
              <td><i>Invalid</i></td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>lastIndex(subString: String): Integer</h2>
        <p>
          Returns the last index of the string "<i>subString</i>" in "<i>self</i>", or "<i>-1</i>" if "<i>self</i>" contains
          no occurrence of "<i>subString</i>".
          Important: String indexes start at 1. Consequently the last character's index in a string
          is equal to the string's length.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.lastIndex('i')/]</td>
              <td>5</td>
            </tr>
            <tr>
              <td>['aString'.lastIndex('Yop')/]</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>['aStringa'.lastIndex('a')/]</td>
              <td>8</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>lastIndex(subString: String, index: Integer): Integer</h2>
        <p>
          Returns the last index of the string "<i>subString</i>" in "<i>self</i>", or "<i>-1</i>" if "<i>self</i>" contains
          no occurrence of "<i>subString</i>" up to the given "<i>index</i>". This operation has the same behavior as the Java
          operation "java.lang.String#lastIndex(java.lang.String, int)".
          Important: String indexes start at 1. Consequently the last character's index in a string
          is equal to the string's length.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aStringa'.lastIndex('a', 3)/]</td>
              <td>1</td>
            </tr>
            <tr>
              <td>['aStringa'.lastIndex('a', 8)/]</td>
              <td>8</td>
            </tr>
            <tr>
              <td>['aStringa'.lastIndex('a', -1)/]</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>['aStringa'.lastIndex('i', 2)/]</td>
              <td>-1</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>matches(regex: String): Boolean</h2>
        <p>
          Returns "<i>true</i>" if "<i>self</i>" matches the given regular expression pattern "<i>regex</i>", "<i>false</i>" otherwise. 
          The regex engine used is that of your runtime JDK. The given pattern is passed "as is" to the method matches of the java
          class String. For more about regular expressions, please refer to the JDK API documentation.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['characters and spaces'.matches('[\\w\\s]+')/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['characters and spaces'.matches('[\\d\\s]+')/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>prefix(str: String): String</h2>
        <p>
          Returns "<i>self</i>" prefixed by the string "<i>str</i>".
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.prefix('PREFIX')/]</td>
              <td>'PREFIXaString'</td>
            </tr>
            <tr>
              <td>['aString'.prefix('')/]</td>
              <td>'aString'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>replace(subStringRegex: String, replacementRegex: String): String</h2>
        <p>
          Substitutes the first occurrence of the string "<i>subStringRegex</i>" in "<i>self</i>" by the "<i>replacementRegex</i>" string
          and returns the resulting string. Returns "<i>self</i>" if it contains no occurrence of the "<i>subStringRegex</i>".
          Note that both the "<i>subStringRegex</i>" and "<i>replacementRegex</i>" are treated as regular expressions.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['replace operation'.replace('p', 'P')/]</td>
              <td>'rePlace operation'</td>
            </tr>
            <tr>
              <td>['repla ce operation'.replace('(\\w+)\\s*', '$1')/]</td>
              <td>'replace operation'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>replaceAll(subStringRegex: String, replacementRegex: String): String</h2>
        <p>
          Substitutes all the strings "<i>subStringRegex</i>" in "<i>self</i>" by the string "<i>replacementRegex</i>" and returns
          the resulting string. Returns "<i>self</i>" if it contains no occurrence of "<i>subStringRegex</i>".
          Note that both "<i>subStringRegex</i>" and "<i>replacementRegex</i>" are treated as regular expressions.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['replaceAll operation'.replaceAll('p', 'P')/]</td>
              <td>'rePlaceAll oPeration'</td>
            </tr>
            <tr>
              <td>['Repla ce All Operation'.replaceAll('(\\w+)\\s*', '$1')/]</td>
              <td>'ReplaceAllOperation'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>size(): Integer</h2>
        <p>
          Returns the number of characters composing "<i>self</i>".
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.size()/]</td>
              <td>7</td>
            </tr>
            <tr>
              <td>[''.size()/]</td>
              <td>0</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>startsWith(subString: String): Boolean</h2>
        <p>
          Returns "<i>true</i>" if "<i>self</i>" starts with the string "<i>subString</i>", "<i>false</i>" otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.startsWith('aStr')/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['aString'.startsWith('Str')/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>['aString'.startsWith('')/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>strcmp(str: String): Integer</h2>
        <p>
          Returns an integer that is either negative, zero or positive depending on whether "<i>str</i>" is
          alphabetically less than, equal to or greater than "<i>self</i>". Note that upper case letters
          come before lower case ones, so that 'AA' is closer to 'AC' than it is to 'Ab'.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.strcmp('aStr')/]</td>
              <td>3</td>
            </tr>
            <tr>
              <td>['aString'.strcmp('a')/]</td>
              <td>6</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>strstr(str: String): Boolean</h2>
        <p>
          Searches for string "<i>str</i>" in "<i>self</i>". Returns "<i>true</i>" if found, "<i>false</i>" otherwise. This operation
          is identical to 'contains'.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.strstr('aStr')/]</td>
              <td>true</td>
            </tr>
            <tr>
              <td>['aString'.strstr('Yop')/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>strtok(str: String, n: Integer): String</h2>
        <p>
          Breaks "<i>self</i>" into a sequence of tokens, each of which delimited by any one of the
          characters in "<i>str</i>", and returns the next element in this sequence. The parameter flag
          should be "<i>0</i>" when strtok is called for the first time and will reset the sequence, "<i>1</i>"
          subsequently so as to access the next element.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['aString'.strtok('S', 0)/]</td>
              <td>'a'</td>
            </tr>
            <tr>
              <td>['aString'.strtok('S', 1)/]</td>
              <td>'tring'</td>
            </tr>
            <tr>
              <td>['aString'.strtok('s', 0)/]</td>
              <td>'aString'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>substitute(origin: String, replacement: String): String</h2>
        <p>
          Substitutes the string "<i>origin</i>" in "<i>self</i>" by the string "<i>replacement</i>" and returns the resulting string. Will
          return "<i>self</i>" if it contains no occurrence of the string "<i>origin</i>".
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['substitute operation'.substitute('t', 'T')/]</td>
              <td>'subsTitute operation'</td>
            </tr>
            <tr>
              <td>['substitute operation'.substitute('Yop', 'T')/]</td>
              <td>'substitute operation'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>substituteAll(origin: String, replacement: String): String</h2>
        <p>
          Substitutes all the string "<i>origin</i>" in "<i>self</i>" by the string "<i>replacement</i>" and returns the
          resulting string. Returns "<i>self</i>" if it contains no occurrence of "<i>origin</i>". Unlike the
          replaceAll operation, neither "<i>origin</i>" nor "<i>replacement</i>" are considered as regular expressions.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['substituteAll operation'.substituteAll('t', 'T')/]</td>
              <td>'subsTiTuTeAll operaTion'</td>
            </tr>
            <tr>
              <td>['substituteAll operation'.substituteAll('Yop', 'T')/]</td>
              <td>'substituteAll operation'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>substring(start: Integer): String</h2>
        <p>
          Returns a substring of self, starting at startIndex (inclusive), until the end of self. Returns
           when the startIndex is either negative, zero, or greater than self's length.
          Important: String indexes start at 1. Consequently the last character's index in a string is equal
          to the string's length.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['substring'.substring(1)/]</td>
              <td>'substring'</td>
            </tr>
            <tr>
              <td>['substring'.substring(3)/]</td>
              <td>'bstring'</td>
            </tr>
            <tr>
              <td>['substring'.substring(0)/]</td>
              <td>Invalid</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>substring(start: Integer, end: Index): String</h2>
        <p>
          Returns a string containing all characters from self starting from index lower up to index upper
          included. Both lower and upper parameters should be contained between 1 and self.size() included.
          lower cannot be greater than upper.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['substring'.substring(1, 5)/]</td>
              <td>'subst'</td>
            </tr>
            <tr>
              <td>['substring'.substring(0, 5)/]</td>
              <td>Invalid</td>
            </tr>
            <tr>
              <td>['substring'.substring(1, 'substring'.size())/]</td>
              <td>'substring'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>toInteger(): Integer</h2>
        <p>
          Returns an Integer of value equal to self, or  if self does not represent an integer.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['5'.toInteger()/]</td>
              <td>5</td>
            </tr>
            <tr>
              <td>['-1'.toInteger()/]</td>
              <td>-1</td>
            </tr>
            <tr>
              <td>['five'.toInteger()/]</td>
              <td>Invalid</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>tokenize(): Sequence(String)</h2>
        <p>
          Returns a sequence of string containing all the parts of the original string tokenized using
          all the whitespaces as tokens.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['this is a string'.tokenize()/]</td>
              <td>Sequence{'this', 'is', 'a', 'string'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>tokenize(subString: String): Sequence(String)</h2>
        <p>
          Returns a sequence containing all parts of self splitted with delimiters defined by the
          characters in String delim.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['this is a string'.tokenize('i')/]</td>
              <td>Sequence{'th', 's ', 's a str', 'ng'}</td>
            </tr>
            <tr>
              <td>['this is a string'.tokenize('o')/]</td>
              <td>Sequence{'this is a string'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>tokenizeLine(): Sequence(String)</h2>
        <p>
          Returns a sequence containing all parts of self splitted with delimiters defined by using the
          line separator.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['this is\n a\r\n string'.tokenizeLine()/]</td>
              <td>Sequence{'this is', ' a', ' string'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>toLower(): String</h2>
        <p>
          Returns self with all characters converted to lowercase.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['TO LoWeR'.toLower()/]</td>
              <td>'to lower'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>toLowerFirst(): String</h2>
        <p>
          Returns a copy of self with its first character converted to lower case and returns it.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['TO LoWeR First'.toLower()/]</td>
              <td>'tO LoWeR First'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>toReal(): Real</h2>
        <p>
          Returns a Real of value equal to self, or  if self does not represent a real.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['3.14'.toReal()/]</td>
              <td>3.14</td>
            </tr>
            <tr>
              <td>['pi'.toReal()/]</td>
              <td>Invalid</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>toUpperFirst(): String</h2>
        <p>
          Returns a copy of self with its first character converted to upper case and returns it.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['to upper first'.toUpperFirst()/]</td>
              <td>'To upper first'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>toUpper(): String</h2>
        <p>
          Returns self with all characters converted to uppercase.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['to upper'.toUpperFirst()/]</td>
              <td>'TO UPPER'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>trim(): String</h2>
        <p>
          Removes all leading and trailing white space characters (tabulation, space, line feed, ...)
          of self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[' a text to trim    '.trim()/]</td>
              <td>'a text to trim'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        
        <hr />
        
        <h2>+ (str: String): String</h2>
        <p>
          Concatenate self with the given string.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>['hello ' + 'world'/]</td>
              <td>'hello world'</td>
            </tr>
          </tbody>
        </table>
        <a href="#string">back to section</a>
        <br />
        <br />
      </section>
      
      <section id="number">
        <div class="page-header">
          <h1>Number <small>operations available on integer and floats.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>abs(): Number</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>div(i: Integer): Integer (integer only)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>floor(): Number</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>max(n: Number): Number</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>min(n: Number): Number</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>mod(i: Integer): Integer (integer only)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>round(): Integer</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>abs(): Number</h2>
        <p>
          Returns the absolute value of self, self if it is already a positive number.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[3.14.abs()/]</td>
              <td>3.14</td>
            </tr>
            <tr>
              <td>[-3.14.abs()/]</td>
              <td>-3.14</td>
            </tr>
            <tr>
              <td>[-(3.14.abs())/]</td>
              <td>-3.14</td>
            </tr>
            <tr>
              <td>[(-3.14).abs()/]</td>
              <td>3.14</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">back to section</a>
        
        <hr />
        
        <h2>div(i: Integer): Integer</h2> (integer only)
        <p>
          Returns the integer quotient of the division of self by i.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[5.div(2)/]</td>
              <td>2</td>
            </tr>
            <tr>
              <td>[5.div(0)/]</td>
              <td>Invalid</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">back to section</a>
        
        <hr />
        
        <h2>floor(): Number</h2>
        <p>
          Returns the integer part of self if it is a Real, self if it is an Integer.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[5.9.floor()/]</td>
              <td>5</td>
            </tr>
            <tr>
              <td>[3.1.floor()/]</td>
              <td>3</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">back to section</a>
        
        <hr />
        
        <h2>max(n: Number): Number</h2>
        <p>
          Returns the greatest number between self and n.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[3.1111.max(3.2)/]</td>
              <td>3.2</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">back to section</a>
        
        <hr />
        
        <h2>min(n: Number): Number</h2>
        <p>
          Returns the lowest number between self and n.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[3.1111.min(3.2)/]</td>
              <td>3.1111</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">back to section</a>
        
        <hr />
        
        <h2>mod(i: Integer): Integer</h2> (integer only)
        <p>
          Returns the integer remainder of the division of self by i.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[7.mod(3)/]</td>
              <td>1</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">back to section</a>
        
        <hr />
        
        <h2>round(): Integer</h2>
        <p>
          Returns the nearest integer to self if it is a Real, self if it is an Integer.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[5.9.round()/]</td>
              <td>6</td>
            </tr>
          </tbody>
        </table>
        <a href="#number">back to section</a>
        <br />
        <br />
      </section>
      
      <section id="boolean">
        <div class="page-header">
          <h1>Boolean <small>operations available on boolean.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>and(b: Boolean): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>implies(b: Boolean): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>or(b: Boolean): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>not(): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>xor(b: Boolean): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>and(b: Boolean): Boolean</h2>
        <p>
          See the table below for the result.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th></th>
              <th>True</th>
              <th>False</th>
            </tr>
          </thead><colgroup><col width="40%" /><col width="30%" /><col width="30%" /></colgroup>
          <tbody>
            <tr>
              <th>True</th>
              <td>true</td>
              <td>false</td>
            </tr>
            <tr>
              <th>False</th>
              <td>false</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">back to section</a>
        
        <hr />
        
        <h2>implies(b: Boolean): Boolean</h2>
        <p>
          See the table below for the result.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th></th>
              <th>True</th>
              <th>False</th>
            </tr>
          </thead><colgroup><col width="40%" /><col width="30%" /><col width="30%" /></colgroup>
          <tbody>
            <tr>
              <th>True</th>
              <td>true</td>
              <td>false</td>
            </tr>
            <tr>
              <th>False</th>
              <td>true</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">back to section</a>
        
        <hr />
        
        <h2>or(b: Boolean): Boolean</h2>
        <p>
          See the table below for the result.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th></th>
              <th>True</th>
              <th>False</th>
            </tr>
          </thead><colgroup><col width="40%" /><col width="30%" /><col width="30%" /></colgroup>
          <tbody>
            <tr>
              <th>True</th>
              <td>true</td>
              <td>true</td>
            </tr>
            <tr>
              <th>False</th>
              <td>true</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">back to section</a>
        
        <hr />
        
        <h2>not(b: Boolean): Boolean</h2>
        <p>
          See the table below for the result.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>True</th>
              <th>False</th>
            </tr>
          </thead><colgroup><col width="50%" /><col width="50%" /></colgroup>
          <tbody>
            <tr>
              <td>false</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">back to section</a>
        
        <hr />
        
        <h2>xor(b: Boolean): Boolean</h2>
        <p>
          See the table below for the result.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th></th>
              <th>True</th>
              <th>False</th>
            </tr>
          </thead><colgroup><col width="40%" /><col width="30%" /><col width="30%" /></colgroup>
          <tbody>
            <tr>
              <th>True</th>
              <td>false</td>
              <td>true</td>
            </tr>
            <tr>
              <th>False</th>
              <td>true</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#boolean">back to section</a>
        <br />
        <br />
      </section>
      
      <section id="collections">
        <div class="page-header">
          <h1>Collections <small>operations available on collections.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="acceleo nonstandard">
              <td>addAll(collection: Collection(T)): Collection(T)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>any(expr: OclExpression): OclAny</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>asBag(): Bag(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>asOrderedSet(): OrderedSet(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>asSequence(): Sequence(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>asSet(): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>collect(expr: OclExpression): Collection(T2)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>collectNested(expr: OclExpression): Collection(T2)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>count(elem: T): Integer</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>excludes(elem: T): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>excludesAll(c: Collection(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>excluding(elem: T): Collection(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>exists(expr: OclExpression): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>filter(oclType: OclType): Collection(OclType)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>flatten(): Collection(T2)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>forAll(expr: OclExpression): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>includes(elem: T): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>includesAll(c: Collection(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>including(elem: T): Collection(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>isEmpty(): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>isUnique(expr: OclExpression): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>max(): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>min(): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>notEmpty(): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>one(expr: OclExpression): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>product(c: Collection(T2)): Set(Tuple(first: T, second: T2))</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>reject(expr: OclExpression): Collection(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>removeAll(collection: Collection(T)): Collection(T)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>select(expr: OclExpression): Collection(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>sep(separator: String): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>sep(prefix: String, separator: String, suffix: String): Sequence(OclAny)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>size(): Integer</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>sortedBy(expr: OclExpression): Sequence(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>sum(): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>addAll(collection: Collection(T)): Collection(T)</h2>
        <p>
          Adds all the content of the given collection to the current collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->addAll(Sequence{'d', 'e', 'f'})/]</td>
              <td>[Sequence{'a', 'b', 'c', 'd', 'e', 'f'}/]</td>
            </tr>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->addAll(Sequence{'d', 'e', 'f'})/]</td>
              <td>[OrderedSet{'a', 'b', 'c', 'd', 'e', 'f'}/]</td>
            </tr>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->addAll(Bag{'d', 'e', 'f'})/]</td>
              <td>[Sequence{'a', 'b', 'c', 'f', 'e', 'd'}/]</td>
            </tr>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->addAll(Set{'d', 'e', 'f'})/]</td>
              <td>[Sequence{'a', 'b', 'c', 'f', 'd', 'e'}/]</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>any(expr: OclExpression): OclAny</h2>
        <p>
          Returns any element contained in self that validates the condition expr, null otherwise.
          Evaluation is shortcut as soon as an element validating expr is found. Note that the result
          of this on unordered collections will be random if more than one element validates expr.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'aWord', 'anotherWord', 'yetAnotherWord'}->any(s: String | s.startsWith('another'))/]</td>
              <td>'anotherWord'</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>asBag(): Bag(T)</h2>
        <p>
          Returns a Bag containing all elements of self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->asBag()/]</td>
              <td>Bag{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[Set{'a', 'b', 'c'}->asBag()/]</td>
              <td>Bag{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->asBag()/]</td>
              <td>Bag{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[Bag{'a', 'b', 'c'}->asBag()/]</td>
              <td>Bag{'a', 'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>asOrderedSet(): OrderedSet(T)</h2>
        <p>
          Returns an OrderedSet containing all elements of self. Element ordering is preserved when
          possible.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <tr>
              <td>[Sequence{'a', 'b', 'c'}->asOrderedSet()/]</td>
              <td>OrderedSet{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[Set{'a', 'b', 'c'}->asOrderedSet()/]</td>
              <td>OrderedSet{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->asOrderedSet()/]</td>
              <td>OrderedSet{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[Bag{'a', 'b', 'c'}->asOrderedSet()/]</td>
              <td>OrderedSet{'a', 'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>asSequence(): Sequence(T)</h2>
        <p>
          Returns a Sequence containing all elements of self. Element ordering is preserved when
          possible.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <tr>
              <td>[Sequence{'a', 'b', 'c'}->asSequence()/]</td>
              <td>Sequence{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[Set{'a', 'b', 'c'}->asSequence()/]</td>
              <td>Sequence{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->asSequence()/]</td>
              <td>Sequence{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[Bag{'a', 'b', 'c'}->asSequence()/]</td>
              <td>Sequence{'a', 'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>asSet(): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <tr>
              <td>[Sequence{'a', 'b', 'c'}->asSet()/]</td>
              <td>Set{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[Set{'a', 'b', 'c'}->asSet()/]</td>
              <td>Set{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->asSet()/]</td>
              <td>Set{'a', 'b', 'c'}</td>
            </tr>
            <tr>
              <td>[Bag{'a', 'b', 'c'}->asSet()/]</td>
              <td>Set{'a', 'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>collect(expr: OclExpression): Collection(T2)</h2>
        <p>
          Returns a collection containing the result of applying expr on all elements contained in self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->collect(s: String | s.toUpper())/]</td>
              <td>[Sequence{'A', 'B', 'C'}/]</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>collectNested(expr: OclExpression): Collection(T2)</h2>
        <p>
          Returns a collection containing all the elements contained in self on which we applied the
          OclExpression expr. The results won't be flattened. The type of the resulting collection
          depends on the type of self.
        </p>
        <p>
          Examples: For the purpose of these examples we'll assume here that we have a Class Person with
          a reference children. Our model contains two persons such as person1.children = {'James', 'Jane'}
          and person2.children = {'John'}.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[self.persons->collectNested(children.firstname)/]</td>
              <td>[Sequence{Sequence{'James', 'Jane'}, Sequence{'John'}} /]</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>count(elem: T): Integer</h2>
        <p>
          Returns how many times object is in the collection self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c', 'd', 'a'}->count('a')/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>excludes(elem: T): Boolean</h2>
        <p>
          Returns true if object is not contained in self, false otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->excludes('a')/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->excludes('d')/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>excludesAll(c: Collection(T)): Boolean</h2>
        <p>
          Returns true if no element of c2 is contained in self, false otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->excludesAll(Sequence{'a', 'd'})/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->excludesAll(Sequence{'d', 'f'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>excluding(elem: T): Collection(T)</h2>
        <p>
          Returns a collection containing all elements of self minus all occurences of object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->excluding('a')/]</td>
              <td>Sequence{'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>exists(expr: OclExpression): Boolean</h2>
        <p>
          Returns true if at least one element in self validates the condition expr, false otherwise.
          The evaluation stops as soon as one element validating expr is found.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->exists(s: String | s.size() > 1)/]</td>
              <td>false</td>
            </tr>
            <tr>
              <td>[Sequence{'a', 'b', 'cccc'}->exists(s: String | s.size() > 1)/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>filter(oclType: OclType): Collection(OclType)</h2>
        <p>
          Filters out of the collection all elements that are not instances of the given type or any of
          its subtypes. The returned collection is typed according to type. Makes it easier to write
          select(e | e.oclIsKindOf(oclType)).oclAsType(oclType).
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{First Child Package, Second Child Package, Element Three}->filter(EClass)/]</td>
              <td>Sequence{Element Three}</td>
            </tr>
            <tr>
              <td>[Sequence{First Child Package, Second Child Package, Element Three}->filter(EPackage)/]</td>
              <td>Sequence{First Child Package, Second Child Package}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>flatten(): Collection(T2)</h2>
        <p>
          Returns a collection containing all elements of self recursively flattened.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{Sequence{'a', 'b', 'c'}, Sequence{'a'}}/]</td>
              <td>Sequence{'a', 'b', 'c', 'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>forAll(expr: OclExpression): Boolean</h2>
        <p>
          Returns true if the all the elements contained in self validate the condition
          expr, false otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->forAll(s: String| s.startsWith('a'))/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>includes(elem: T): Boolean</h2>
        <p>
          Returns true if object is contained in self, false otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->includes('a')/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>includesAll(c: Collection(T)): Boolean</h2>
        <p>
          Returns true if all element of c2 are contained in self, false otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->includesAll(Sequence{'a', 'b'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>including(elem: T): Collection(T)</h2>
        <p>
          Returns a collection containing all elements of self followed by object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->including('a')/]</td>
              <td>Sequence{'a', 'b', 'c', 'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>isEmpty(): Boolean</h2>
        <p>
          Returns true if self is empty, false otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->isEmpty()/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>isUnique(expr: OclExpression): Boolean</h2>
        <p>
          Returns true if all elements contained in self evaluate to a distinct value for expr.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c', 'a'}->isUnique(s: String | s.toUpper())/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>max(): T</h2>
        <p>
          The element with the maximum value of all elements in self. Elements must be of a type supporting the max operation.
          The max operation  supported by the elements  must take one parameter of type T and be both associative and commutative.
          UnlimitedNatural, Integer and Real fulfill this condition.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{5, 9, 2}->max()/]</td>
              <td>9</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>min(): T</h2>
        <p>
          The element with the minimum value of all elements in self. Elements must be of a type supporting the min operation.
          The min operation  supported by the elements  must take one parameter of type T and be both associative and commutative.
          UnlimitedNatural, Integer and Real fulfill this condition.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{5, 9, 2}->min()/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>notEmpty(): Boolean</h2>
        <p>
          Returns true if self contains at least one element, false otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->notEmpty()/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>one(expr: OclExpression): Boolean</h2>
        <p>
          Returns true if there is only one element contained in self that validates
          the condition expr, false otherwise.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->one(s: String| s.startsWith('z'))/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>product(c: Collection(T2)): Set(Tuple(first: T, second: T2))</h2>
        <p>
          Returns a Set of Tuples which represents the cartesian product of self with c2.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b'}->product(Sequence{1, 2})/]</td>
              <td>Set{Tuple{'a', 1}, Tuple{'b', 1}, Tuple{'b', 2}, Tuple{'a', 2}}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>reject(expr: OclExpression): Collection(T)</h2>
        <p>
          Returns a collection with all elements of self except for those who validate the
          OclExpression expr.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->reject(s: String | s.startsWith('b'))/]</td>
              <td>Sequence{'a', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>removeAll(collection: Collection(T)): Collection(T)</h2>
        <p>
          Removes all the content of the given collection from the current collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->removeAll(Sequence{'b', 'c'})/]</td>
              <td>Sequence{'a'}</td>
            </tr>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->removeAll(Bag{'b', 'c'})/]</td>
              <td>Sequence{'a'}</td>
            </tr>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->removeAll(OrderedSet{'b', 'c'})/]</td>
              <td>Sequence{'a'}</td>
            </tr>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->removeAll(Set{'b', 'c'})/]</td>
              <td>Sequence{'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>select(expr: OclExpression): Collection(T)</h2>
        <p>
          Returns a collection with all elements of self that validate the OclExpression expr.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->select(s: String | not s.startsWith('a'))/]</td>
              <td>Sequence{'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>sep(separator: String): Collection(OclAny)</h2>
        <p>
          Returns all elements from the source collection separated by an element composed of the
          String separator.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->sep('haha')/]</td>
              <td>Sequence{'a', 'haha', 'b', 'haha', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>sep(prefix: String, separator: String, suffix: String): Collection(OclAny)</h2>
        <p>
          Returns all elements from the source collection separated by an element composed of the
          String separator with the prefix as the first element of the collection and the suffix as
          the latest element of the collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->sep('prefix', 'haha', 'suffix')/]</td>
              <td>Sequence{'prefix', 'a', 'haha', 'b', 'haha', 'c', 'suffix'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>size(): Integer</h2>
        <p>
          Returns the number of elements contained in self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->size()/]</td>
              <td>3</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>sortedBy(expr: OclExpression): Sequence(T)</h2>
        <p>
          Returns a sorted collection containing all elements from self sorted in accordance with the OclExpression expr.
          This can be used on all kind of collections yet will always yield a Sequence-typed result except for OrderedSet which returns an OrderedSet.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'aaaa', 'bb', 'ccc'}->sortedBy(s: String | s.size())/]</td>
              <td>Sequence{'bb', 'ccc', 'aaaa'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        
        <hr />
        
        <h2>sum(): T</h2>
        <p>
          The addition of all elements in self. Elements must be of a type supporting the + operation.
          The + operation must take one parameter of type T and be both associative: (a+b) c = a(b+c),
          and commutative: a+b = b+a. UnlimitedNatural, Integer and Real fulfill this condition.
          If the + operation is not both associative and commutative, the sum expression is not well-formed,
          which may result in unpredictable results during evaluation. If an implementation is able to detect
          a lack of associativity or commutativity, the implementation may bypass the evaluation and return an invalid result. 
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{1, 2, 3}->sum()/]</td>
              <td>6</td>
            </tr>
          </tbody>
        </table>
        <a href="#collection">back to section</a>
        <br />
        <br />
      </section>
      
      <section id="sequence">
        <div class="page-header">
          <h1>Sequence <small>operations available on sequences.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>= (seq: Sequence(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt; (seq: Sequence(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>append(elem: T): Sequence(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>at(index: Integer): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>drop(n: Integer): Sequence(T)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>dropRight(n: Integer): Sequence(T)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith(subCollection: OrderedSet(T)): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith(subCollection: Sequence(T)): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>first(): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>indexOf(elem: T): Integer</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>indexOfSlice(subCollection: OrderedSet(T)): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>indexOfSlice(subCollection: Sequence(T)): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>insertAt(index: Integer, elem: T): Sequence(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>last(): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOf(elem: T): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOfSlice(subCollection: OrderedSet(T)): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOfSlice(subCollection: Sequence(T)): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>prepend(elem: T): Sequence(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>reverse(): Sequence(T)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith(subCollection: OrderedSet(T)): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith(subCollection: Sequence(T)): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>subSequence(startIndex: Integer, endIndex: Integer):Sequence(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>union(c: Sequence(T)): Sequence(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>= (seq: Sequence(T)): Boolean</h2>
        <p>
          Returns true if self contains the very same objects as seq in the very same order as they are in seq.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'} = Sequence{'a', 'b', 'c'}/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>&lt;&gt; (seq: Sequence(T)): Boolean</h2>
        <p>
          Returns true if self does not contain the same objects as seq, or if these objects are not in the same order as they are in seq.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'} &lt;&gt; Sequence{'a', 'b', 'c'}/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>append(elem: T): Sequence(T)</h2>
        <p>
          Returns a Sequence containing all elements of self followed by object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}.append('d')/]</td>
              <td>Sequence{'a', 'b', 'c', 'd'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>at(index: Integer): T</h2>
        <p>
          Returns the element of self at the index position.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->at(1)/]</td>
              <td>'a'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>drop(n: Integer): Sequence(T)</h2>
        <p>
          Returns the collection after the removal of the n first elements.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->drop(2)/]</td>
              <td>'c'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>dropRight(n: Integer): Sequence(T)</h2>
        <p>
          Returns the collection after the removal of the n latest elements.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->dropRight(2)/]</td>
              <td>'a'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>endsWith(subCollection: OrderedSet(T)): Boolean</h2>
        <p>
          Indicates if the self collection ends with the given sub-collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->endsWith(OrderedSet{'b', 'c'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>endsWith(subCollection: Sequence(T)): Boolean</h2>
        <p>
          Indicates if the self collection ends with the given sub-collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->endsWith(Sequence{'b', 'c'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>first(): T</h2>
        <p>
          Returns the first element of the sequence.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->first()/]</td>
              <td>'a'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>indexOf(elem: T): Integer</h2>
        <p>
          Returns the position of object in sequence self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->indexOf('a')/]</td>
              <td>1</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>indexOfSlice(subCollection: Sequence(T)): Integer</h2>
        <p>
          Returns the position of the subcollection in the sequence self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->indexOfSlice(Sequence{'b', 'c'})/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>indexOfSlice(subCollection: OrderedSet(T)): Integer</h2>
        <p>
          Returns the position of the subcollection in the sequence self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->indexOfSlice(OrderedSet{'b', 'c'})/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>insertAt(index: Integer, elem: T): Sequence(T)</h2>
        <p>
          Returns a Sequence containing self with object inserted at the index position.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->insertAt(1, 'z')/]</td>
              <td>Sequence{'z', 'a', 'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>last(): T</h2>
        <p>
          Returns the last element of self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->last()/]</td>
              <td>'c'</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>lastIndexOf(elem: T): Integer</h2>
        <p>
          Returns the last position of the object elem in the sequence self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c', 'a'}->lastIndexOf('a')/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>lastIndexOfSlice(subCollection: Sequence(T)): Integer</h2>
        <p>
          Returns the last position of the subcollection in the sequence self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c', 'b', 'c'}->lastIndexOfSlice(Sequence{'b', 'c'})/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>lastIndexOfSlice(subCollection: OrderedSet(T)): Integer</h2>
        <p>
          Returns the last position of the subcollection in the sequence self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c', 'b', 'c'}->lastIndexOfSlice(OrderedSet{'b', 'c'})/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>prepend(elem: T): Sequence(T)</h2>
        <p>
          Returns a Sequence containing object followed by all elements of self .
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->prepend('z')/]</td>
              <td>Sequence{'z', 'a', 'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>reverse(): Sequence(T)</h2>
        <p>
          Reverses the order of the collection: the last element becomes the first and vice-versa.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->reverse()/]</td>
              <td>Sequence{'c', 'b', 'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>startsWith(subCollection: Sequence(T)): Boolean</h2>
        <p>
          Returns true if self starts with the given sub-collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->startsWith(Sequence{'a', 'b'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>startsWith(subCollection: OrderedSet(T)): Boolean</h2>
        <p>
          Returns true if self starts with the given sub-collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->startsWith(OrderedSet{'a', 'b'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>subSequence(startIndex: Integer, endIndex: Integer):Sequence(T)</h2>
        <p>
          Returns a Sequence containing all elements of self between the positions 'startIndex' and 'endIndex'.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->subSequence{1, 2}/]</td>
              <td>Sequence{'a', 'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        
        <hr />
        
        <h2>union(c: Sequence(T)): Sequence(T)</h2>
        <p>
          Returns a Sequence containing all elements of self followed by all elements of seq.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Sequence{'a', 'b', 'c'}->union(Sequence{'d', 'e'})/]</td>
              <td>Sequence{'a', 'b', 'c', 'd', 'e'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#sequence">back to section</a>
        <br />
        <br />
      </section>
      
      <section id="orderedset">
        <div class="page-header">
          <h1>Ordered Set <small>operations available on ordered sets.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>= (c: Set(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>= (c: OrderedSet(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt; (c: Set(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt; (c: Set(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>- (c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>append(elem: T): OrderedSet(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>at(index: Integer): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>drop(n: Integer): OrderedSet(T)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>dropRight(n: Integer): OrderedSet(T)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith(subCollection: OrderedSet(T)): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>endsWith(subCollection: Sequence(T)): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>first(): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>indexOf(elem: T): Integer</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>indexOfSlice(subCollection: OrderedSet(T)): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>indexOfSlice(subCollection: Sequence(T)): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>insertAt(index: Integer, elem: T): OrderedSet(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>intersection(c: Bag(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>intersection(c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>last(): T</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOf(elem: T): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOfSlice(subCollection: OrderedSet(T)): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>lastIndexOfSlice(subCollection: Sequence(T)): Integer</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>prepend(elem: T): OrderedSet(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>reverse(): OrderedSet(T)</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith(subCollection: OrderedSet(T)): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="acceleo nonstandard">
              <td>startsWith(subCollection: Sequence(T)): Boolean</td>
              <td>Acceleo</td>
              <td>No</td>
            </tr>
            <tr class="ocl standard">
              <td>subOrderedSet(startIndex: Integer, endIndex: Integer): OrderedSet(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>symmetricDifference(c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>union(c: Bag(T)): Bag(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>union(c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>= (c: Set(T)): Boolean</h2>
        <p>
          Returns true if self contains the same objects as set.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'} = Set{'a', 'b', 'c'}/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>= (c: OrderedSet(T)): Boolean</h2>
        <p>
          Returns true if self contains the same objects as orderedset regardless of element ordering.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'} = OrderedSet{'a', 'b', 'c'}/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>&lt;&gt; (c: Set(T)): Boolean</h2>
        <p>
          Returns true if self does not contain the same objects as set.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'} &lt;&gt; Set{'a', 'b', 'c'}/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>&lt;&gt; (c: Set(T)): Boolean</h2>
        <p>
          Returns true if self does not contain the same objects as orderedset.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'} &lt;&gt; OrderedSet{'a', 'b', 'c'}/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>- (c: Set(T)): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self minus all elements of c.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'} - Set{'a', 'c'}/]</td>
              <td>OrderedSet{'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>append(elem: T): OrderedSet(T)</h2>
        <p>
          Returns an OrderedSet containing all elements of self followed by object.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->append('d')/]</td>
              <td>OrderedSet{'a', 'b', 'c', 'd'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>at(index: Integer): T</h2>
        <p>
          Returns the element of self located at position index in the collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->at(1)/]</td>
              <td>'a'</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>drop(n: Integer): OrderedSet(T)</h2>
        <p>
          Returns an ordered set containing all the element of self minus the n first elements.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->drop(2)/]</td>
              <td>OrderedSet{'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>dropRight(n: Integer): OrderedSet(T)</h2>
        <p>
          Returns an ordered set containing all the element of self minus the n last elements.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->dropRight(2)/]</td>
              <td>'a'</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>endsWith(subCollection: OrderedSet(T)): Boolean</h2>
        <p>
          Indicates if self ends with the given sub-collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->endsWith(OrderedSet{'b', 'c'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>endsWith(subCollection: Sequence(T)): Boolean</h2>
        <p>
          Indicates if self ends with the given sub-collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->endsWith(Sequence{'b', 'c'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>first(): T</h2>
        <p>
          Returns the first element of self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->first()/]</td>
              <td>'a'</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>indexOf(elem: T): Integer</h2>
        <p>
          Returns the position of elem in self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->indexOf('b')/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>indexOfSlice(subCollection: OrderedSet(T)): Integer</h2>
        <p>
          Returns the index of the sub-collection in self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->indexOfSlice(OrderedSet{'b', 'c'})/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>indexOfSlice(subCollection: Sequence(T)): Integer</h2>
        <p>
          Returns the index of the sub-collection in self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->indexOfSlice(Sequence{'b', 'c'})/]</td>
              <td>2</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>insertAt(index: Integer, elem: T): OrderedSet(T)</h2>
        <p>
          Returns an OrderedSet containing self with object inserted at the index position.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->insertAt(1, 'z')/]</td>
              <td>OrderedSet{'z', 'a', 'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>intersection(c: Bag(T)): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self that are also contained by c.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->intersection(Bag{'a', 'b'})/]</td>
              <td>Set{'a', 'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>intersection(c: Set(T)): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self that are also contained by c.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->intersection(Set{'a', 'b'})/]</td>
              <td>Set{'a', 'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>last(): T</h2>
        <p>
          Returns the last element of self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->last()/]</td>
              <td>'c'</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>lastIndexOf(elem: T): Integer</h2>
        <p>
          Returns the last index of elem in self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c', 'b'}->lastIndexOf('b')/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>lastIndexOfSlice(subCollection: OrderedSet(T)): Integer</h2>
        <p>
          Returns the last index of the given sub-collection in self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c', 'b', 'c'}->lastIndexOfSlice(OrderedSet{'b', 'c'})/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>lastIndexOfSlice(subCollection: Sequence(T)): Integer</h2>
        <p>
          Returns the last index of the given sub-collection in self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c', 'b', 'c'}->lastIndexOfSlice(Sequence{'b', 'c'})/]</td>
              <td>4</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>prepend(elem: T): OrderedSet(T)</h2>
        <p>
          Returns an OrderedSet containing object followed by all elements of self.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->prepend('z')/]</td>
              <td>OrderedSet{'z', 'a', 'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2reverse(): OrderedSet(T)</h2>
        <p>
          Returns self reversed, the first element becoming the last one.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->reverse()/]</td>
              <td>OrderedSet{'c', 'b', 'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>startsWith(subCollection: OrderedSet(T)): Boolean</h2>
        <p>
          Indicates if self starts with the given sub-collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->startsWith(OrderedSet{'a', 'b'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>startsWith(subCollection: Sequence(T)): Boolean</h2>
        <p>
          Indicates if self starts with the given sub-collection.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->startsWith(Sequence{'a', 'b'})/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>subOrderedSet(startIndex: Integer, endIndex: Integer): OrderedSet(T)</h2>
        <p>
          Returns an OrderedSet containing all elements of self between the positions startIndex and endIndex.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->subOrderedSet(1, 2)/]</td>
              <td>OrderedSet{'a', 'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>symmetricDifference(c: Set(T)): Set(T)</h2>
        <p>
          Returns a Set containing all of the elements of self and set that are not present in both.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->symmetricDifference(Set{'a'})/]</td>
              <td>Set{'b', 'c'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>union(c: Bag(T)): Bag(T)</h2>
        <p>
          Returns a Bag containing all elements of self followed by all elements of bag.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->union(Bag{'d', 'e'})/]</td>
              <td>Bag{'a', 'b', 'c', 'd', 'e'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        
        <hr />
        
        <h2>union(c: Set(T)): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self followed by all elements of set.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[OrderedSet{'a', 'b', 'c'}->union(Set{'d', 'e'})/]</td>
              <td>Set{'a', 'b', 'c', 'd', 'e'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#orderedset">back to section</a>
        <br />
        <br />
      </section>
      
      <section id="set">
        <div class="page-header">
          <h1>Set <small>operations available on sets.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>= (c: Set(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt; (c: Set(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>- (c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>intersection(c: Bag(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>intersection(c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>symmetricDifference(c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>union(c: Bag(T)): Bag(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>union(c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>= (c: Set(T)): Boolean</h2>
        <p>
          Returns true if self contains the same objects as c.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Set{'a', 'b', 'c'} = Set{'b', 'c', 'a'}/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">back to section</a>
        
        <hr />
        
        <h2>&lt;&gt; (c: Set(T)): Boolean</h2>
        <p>
          Returns true if self does not contains the same objects as c.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Set{'a', 'b', 'c'} &lt;&gt; Set{'b', 'c', 'a'}/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">back to section</a>
        
        <hr />
        
        <h2>- (c: Set(T)): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self minus all elements of set.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Set{'a', 'b', 'c'} - Set{'a'}/]</td>
              <td>Set{'c', 'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">back to section</a>
        
        <hr />
        
        <h2>intersection(c: Bag(T)): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self that are also contained in c.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Set{'a', 'b', 'c'}->intersection(Bag{'a'})/]</td>
              <td>Set{'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">back to section</a>
        
        <hr />
        
        <h2>intersection(c: Set(T)): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self that are also contained in c.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Set{'a', 'b', 'c'}->intersection(Set{'a'})/]</td>
              <td>Set{'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">back to section</a>
        
        <hr />
        
        <h2>symmetricDifference(c: Set(T)): Set(T)</h2>
        <p>
          Returns a Set containing all of the elements of self and set that are not present in both.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Set{'a', 'b', 'c'}->symmetricDifference(Set{'b', 'c', 'd'})/]</td>
              <td>Set{'a', 'd'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">back to section</a>
        
        <hr />
        
        <h2>union(c: Bag(T)): Bag(T)</h2>
        <p>
          Returns a Bag containing all elements of self and all elements of bag.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Set{'a', 'b', 'c'}->union(Bag{'a'})/]</td>
              <td>Bag{'a', 'a', 'c', 'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">back to section</a>
        
        <hr />
        
        <h2>union(c: Set(T)): Set(T)</h2>
        <p>
          Returns true if self contains the same objects as set.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Set{'a', 'b', 'c'}->union(Set{'d'})/]</td>
              <td>Set{'d', 'b', 'c', 'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#set">back to section</a>
        <br />
        <br />
      </section>
      
      <section id="bag">
        <div class="page-header">
          <h1>Bag <small>operations available on bags.</small></h1>
        </div>        
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Origin</th>
              <th>Standard</th>
            </tr>
          </thead>
          <tbody>
            <tr class="ocl standard">
              <td>= (c: Bag(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>&lt;&gt; (c: Bag(T)): Boolean</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>intersection(c: Bag(T)): Bag(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>intersection(c: Set(T)): Set(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>union(c: Bag(T)): Bag(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
            <tr class="ocl standard">
              <td>union(c: Set(T)): Bag(T)</td>
              <td>OCL</td>
              <td>Yes</td>
            </tr>
          </tbody>
        </table>
        
        <a href="#">back to top</a>
        <hr />
        
        <h2>= (c: Bag(T)): Boolean</h2>
        <p>
          Returns true if self contains the same objects as bag in the same quantities.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Bag{'a', 'b', 'c'} = Bag{'c', 'b', 'a'}/]</td>
              <td>true</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">back to section</a>
        
        <hr />
        
        <h2>&lt;&gt; (c: Bag(T)): Boolean</h2>
        <p>
          Returns true if self does not contains the same objects as bag in the same quantities.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Bag{'a', 'b', 'c'} &lt;&gt; Bag{'b', 'a', 'c'}/]</td>
              <td>false</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">back to section</a>
        
        <hr />
        
        <h2>intersection(c: Bag(T)): Bag(T)</h2>
        <p>
          Returns a Bag containing all elements of self that are also contained by bag.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Bag{'a', 'b', 'c'}->intersection(Bag{'a'})/]</td>
              <td>Bag{'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">back to section</a>
        
        <hr />
        
        <h2>intersection(c: Set(T)): Set(T)</h2>
        <p>
          Returns a Set containing all elements of self that are also contained by set.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Bag{'a', 'b', 'c'}->intersection(Set{'a'})/]</td>
              <td>Set{'a'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">back to section</a>
        
        <hr />
        
        <h2>union(c: Bag(T)): Bag(T)</h2>
        <p>
          Returns a Bag containing all elements of self and all elements of bag.
        </p>
        <table class="table table-striped table-bordered table-condensed">
          <thead>
            <tr>
              <th>Expression</th>
              <th>Result</th>
            </tr>
          </thead><colgroup><col width="60%" /><col width="40%" /></colgroup>
          <tbody>
            <tr>
              <td>[Bag{'a', 'b', 'c'}->union(Bag{'a', 'd'})/]</td>
              <td>Bag{'a', 'd', 'c', 'a', 'b'}</td>
            </tr>
          </tbody>
        </table>
        <a href="#bag">back to section</a>
        
        <br />
        <br />
      </section>
      
      <footer class="footer">
        <p>
          The material in these guides are Copyright (c) 2008, 2012 Obeo. This material is available under the Eclipse Public License v1.0
        </p>
      </footer>
    </div>
  </body>
</html>
