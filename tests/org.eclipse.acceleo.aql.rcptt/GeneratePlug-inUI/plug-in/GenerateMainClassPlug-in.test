--- RCPTT testcase ---
Format-Version: 1.0
Contexts: _qJ-qYAiZEfC07LF6VSMd-w,_Ayow4KrpEeqpkej7GeVvKQ
Element-Name: GenerateMainClassPlug-in
Element-Type: testcase
Element-Version: 3.0
External-Reference: 
Id: _uWAckAiyEfC07LF6VSMd-w
Runtime-Version: 2.5.4.202210020716
Save-Time: 9/2/25, 3:51â€¯PM
Testcase-Type: ecl

------=_.content-0a7243a0-75d3-3d5f-9791-539de0e5b7ac
Content-Type: text/ecl
Entry-Name: .content

get-view "Package Explorer" | get-tree | select "test/src/test/test.mtl" | get-menu 
    -path "Initialize Generator Launcher/Eclipse UI Project" | click -metaKeys ""
with [get-window "Generation comparison"] {
    get-tree | select "test/META-INF/MANIFEST.MF" | double-click
    get-button "Copy Current Change from Left to Right" | click -metaKeys ""
    get-button Commit | click -metaKeys ""
}
get-view "Package Explorer" | get-tree | select "test/src/test/TestGenerator.java" | double-click
get-editor "TestGenerator.java" | get-text-viewer | get-property text | equals "//Start of user code copyright\n"
    + "package test;\n\n"
    + "//Start of user code imports\n\n"
    + "import java.io.File;\n\n"
    + "//End of user code\n\n"
    + "/**\n"
    + " * Standalone launcher for test::test.\n"
    + " * \n"
    + " * @author username\n"
    + " * @generated\n"
    + " */\n"
    + "public class TestGenerator {\n\n"
    + "\t/**\n"
    + "\t * The {@link List} of resources to load.\n"
    + "\t * \n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected final List<String> resources;\n\n"
    + "\t/**\n"
    + "\t * The target folder for the generation.\n"
    + "\t * \n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected final String target;\n\n"
    + "\t/**\n"
    + "\t * Constructor.\n"
    + "\t * \n"
    + "\t * @param resources the {@link List} of model resources to load\n"
    + "\t * @param target    the target folder for the generation\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tpublic TestGenerator(List<String> resources, String target) {\n"
    + "\t\tthis.resources = resources;\n"
    + "\t\tthis.target = target;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Main entry point.\n"
    + "\t * \n"
    + "\t * @param args resources separated by a comma, target folder\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tpublic static void main(String[] args) {\n"
    + "\t\tif (args.length == 2) {\n"
    + "\t\t\tfinal List<String> resources = new ArrayList<>();\n"
    + "\t\t\tfor (String resource : args[0].split(\",\")) {\n"
    + "\t\t\t\tresources.add(resource.trim());\n"
    + "\t\t\t}\n"
    + "\t\t\tfinal String target = args[1];\n"
    + "\t\t\tfinal TestGenerator generator = new TestGenerator(resources, target);\n"
    + "\t\t\tgenerator.generate(getMonitor());\n"
    + "\t\t} else {\n"
    + "\t\t\tprintUsage();\n"
    + "\t\t}\n\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Print the usage.\n"
    + "\t * \n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprivate static void printUsage() {\n"
    + "\t\tSystem.out.println(\"Usage: <resources> <target>\");\n"
    + "\t\tSystem.out.println(\"Example: model1.xmi,model2.xmi src-gen/\");\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Gets the progress {@link Monitor}.\n"
    + "\t * \n"
    + "\t * @return the progress {@link Monitor}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprivate static Monitor getMonitor() {\n"
    + "\t\treturn new Printing(new PrintStream(System.out));\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Generates.\n"
    + "\t * \n"
    + "\t * @param monitor the progress {@link Monitor}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tpublic void generate(Monitor monitor) {\n"
    + "\t\t// inputs\n"
    + "\t\tfinal String moduleQualifiedName = getModuleQualifiedName();\n"
    + "\t\tfinal URI targetURI = getTargetURI(target);\n"
    + "\t\tfinal Map<String, String> options = getOptions();\n\n"
    + "\t\t// create the resource set used to load models\n"
    + "\t\tfinal Object generationKey = new Object();\n"
    + "\t\tfinal List<Exception> exceptions = new ArrayList<>();\n"
    + "\t\tfinal ResourceSet resourceSet = createDefaultResourceSet();\n"
    + "\t\tfinal ResourceSet resourceSetForModels = createResourceSetForModel(generationKey, options, exceptions,\n"
    + "\t\t\t\tresourceSet);\n\n"
    + "\t\tstandaloneInitialization(resourceSetForModels);\n\n"
    + "\t\t// prepare Acceleo environment\n"
    + "\t\tfinal IQualifiedNameResolver resolver = createResolver();\n"
    + "\t\tfinal IQualifiedNameQueryEnvironment queryEnvironment = createAcceleoQueryEnvironment(options, resolver,\n"
    + "\t\t\t\tresourceSetForModels);\n"
    + "\t\tfinal AcceleoEvaluator evaluator = createAcceleoEvaluator(targetURI, resolver, queryEnvironment);\n"
    + "\t\tfinal IAcceleoGenerationStrategy strategy = createGenerationStrategy(resourceSetForModels);\n\n"
    + "\t\tfinal Module module = (Module) resolver.resolve(moduleQualifiedName);\n"
    + "\t\tfinal Set<String> nsURIs = AQLUtils.getAllNeededEPackages(resolver, moduleQualifiedName);\n"
    + "\t\tAQLUtils.registerEPackages(queryEnvironment, EPackage.Registry.INSTANCE, nsURIs);\n"
    + "\t\tfinal URI logURI = AcceleoUtil.getlogURI(targetURI, options.get(AcceleoUtil.LOG_URI_OPTION));\n"
    + "\t\tfinal List<Template> mainTemplates = getTemplates(module);\n\n"
    + "\t\tmonitor.beginTask(\"Generating\", resources.size() + 1 + mainTemplates.size() * resources.size() + 1);\n"
    + "\t\t// load models\n"
    + "\t\tfinal List<Resource> modelResources = loadResources(resourceSetForModels, resources, monitor);\n\n"
    + "\t\tmonitor.subTask(\"Before generation\");\n"
    + "\t\tbeforeGeneration(evaluator, queryEnvironment, module, resourceSetForModels, strategy, targetURI, logURI);\n"
    + "\t\tmonitor.worked(1);\n"
    + "\t\ttry {\n"
    + "\t\t\tfinal Map<EClass, List<EObject>> valuesCache = new LinkedHashMap<>();\n"
    + "\t\t\tfor (Template template : mainTemplates) {\n"
    + "\t\t\t\tfinal EClassifierTypeLiteral eClassifierTypeLiteral = (EClassifierTypeLiteral) template.getParameters()\n"
    + "\t\t\t\t\t\t.get(0).getType().getAst();\n"
    + "\t\t\t\tfinal List<EObject> values = getValues(queryEnvironment, valuesCache, eClassifierTypeLiteral,\n"
    + "\t\t\t\t\t\tresourceSetForModels, modelResources, monitor);\n\n"
    + "\t\t\t\tfinal String parameterName = template.getParameters().get(0).getName();\n"
    + "\t\t\t\tMap<String, Object> variables = new LinkedHashMap<>();\n"
    + "\t\t\t\tfor (EObject value : values) {\n"
    + "\t\t\t\t\tvariables.put(parameterName, value);\n"
    + "\t\t\t\t\tAcceleoUtil.generate(template, variables, evaluator, queryEnvironment, strategy, targetURI, logURI,\n"
    + "\t\t\t\t\t\t\tmonitor);\n"
    + "\t\t\t\t\tif (monitor.isCanceled()) {\n"
    + "\t\t\t\t\t\treturn;\n"
    + "\t\t\t\t\t}\n"
    + "\t\t\t\t}\n"
    + "\t\t\t\tmonitor.worked(1);\n"
    + "\t\t\t\tif (monitor.isCanceled()) {\n"
    + "\t\t\t\t\treturn;\n"
    + "\t\t\t\t}\n"
    + "\t\t\t}\n"
    + "\t\t} finally {\n"
    + "\t\t\tif (evaluator instanceof AcceleoProfilerEvaluator) {\n"
    + "\t\t\t\tIProfiler profiler = ((AcceleoProfilerEvaluator) evaluator).getProfiler();\n"
    + "\t\t\t\tProfileResource profileResource = profiler.getResource();\n"
    + "\t\t\t\tprofileResource.setStartResource(resolver.getSourceURI(moduleQualifiedName).toString());\n"
    + "\t\t\t\ttry {\n"
    + "\t\t\t\t\tprofiler.save(URI.createURI(targetURI.toString() + \"/\" + module.getName() + \".mtlp\"));\n"
    + "\t\t\t\t} catch (IOException e) {\n"
    + "\t\t\t\t\tfinal Diagnostic diagnostic = new BasicDiagnostic(Diagnostic.ERROR, getClass().getCanonicalName(),\n"
    + "\t\t\t\t\t\t\t0, e.getMessage(), new Object[] { e });\n"
    + "\t\t\t\t\tevaluator.getGenerationResult().addDiagnostic(diagnostic);\n"
    + "\t\t\t\t}\n"
    + "\t\t\t}\n"
    + "\t\t\tAQLUtils.cleanResourceSetForModels(generationKey, resourceSetForModels);\n"
    + "\t\t\tAcceleoUtil.cleanServices(queryEnvironment, resourceSetForModels);\n"
    + "\t\t\tprintDiagnostics(evaluator.getGenerationResult());\n"
    + "\t\t\tmonitor.subTask(\"After generation\");\n"
    + "\t\t\tafterGeneration(evaluator.getGenerationResult());\n"
    + "\t\t\tmonitor.worked(1);\n"
    + "\t\t}\n\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Gets the {@link List} of {@link Template} to generate for the given\n"
    + "\t * {@link Module}.\n"
    + "\t * \n"
    + "\t * @param module the {@link Module}\n"
    + "\t * @return the {@link List} of {@link Template} to generate for the given\n"
    + "\t *         {@link Module}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected List<Template> getTemplates(Module module) {\n"
    + "\t\treturn AcceleoUtil.getMainTemplates(module);\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Gets the {@link List} of {@link EObject} values to use.\n"
    + "\t * \n"
    + "\t * @param queryEnvironment     the {@link IQualifiedNameQueryEnvironment}\n"
    + "\t * @param valuesCache          the cache for any previous values\n"
    + "\t * @param type                 the {@link TypeLiteral}\n"
    + "\t * @param resourceSetForModels the {@link ResourceSet} for models\n"
    + "\t * @param modelResources       the {@link List} of loaded {@link Resource}\n"
    + "\t * @param monitor              the progress {@link Monitor}, it must consumes\n"
    + "\t *                             the resources.size()\n"
    + "\t * @return the {@link List} of {@link EObject} values to use\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected List<EObject> getValues(IQualifiedNameQueryEnvironment queryEnvironment,\n"
    + "\t\t\tMap<EClass, List<EObject>> valuesCache, TypeLiteral type, ResourceSet resourceSetForModels,\n"
    + "\t\t\tList<Resource> modelResources, Monitor monitor) {\n"
    + "\t\tfinal List<EObject> values = AcceleoUtil.getValues(type, queryEnvironment, modelResources, valuesCache,\n"
    + "\t\t\t\tmonitor);\n"
    + "\t\treturn values;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Gets the module qualified name.\n"
    + "\t * \n"
    + "\t * @return the module qualified name\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected String getModuleQualifiedName() {\n"
    + "\t\treturn \"test::test\";\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Gets the target folder {@link URI}.\n"
    + "\t * \n"
    + "\t * @param target the target folder {@link String}.\n"
    + "\t * @return the target folder {@link URI}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected URI getTargetURI(String target) {\n"
    + "\t\treturn URI.createFileURI(new File(target).getAbsolutePath() + \"/\");\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Gets the {@link Map} of options for the generation.\n"
    + "\t * \n"
    + "\t * @return the {@link Map} of options for the generation\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected Map<String, String> getOptions() {\n"
    + "\t\tMap<String, String> res = new LinkedHashMap<>();\n\n"
    + "\t\tres.put(AcceleoUtil.LOG_URI_OPTION, \"acceleo.log\");\n"
    + "\t\tres.put(AcceleoUtil.NEW_LINE_OPTION, System.lineSeparator());\n"
    + "\t\t// res.put(AQLUtils.INSTALL_CROSS_REFERENCE_ADAPTER_OPTION,\n"
    + "\t\t// Boolean.TRUE.toString());\n"
    + "\t\t// res.put(AQLUtils.PROPERTIES_URIS_OPTION,\n"
    + "\t\t// \"file1.properties,file2.properties\");\n\n"
    + "\t\treturn res;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Creates the default {@link ResourceSet}.\n"
    + "\t * \n"
    + "\t * @return the created default {@link ResourceSet}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected ResourceSet createDefaultResourceSet() {\n"
    + "\t\treturn new ResourceSetImpl();\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Creates the {@link ResourceSet} for models.\n"
    + "\t * \n"
    + "\t * @param generationKey the generation key\n"
    + "\t * @param options       the {@link Map} of options\n"
    + "\t * @param exceptions    the {@link List} of exceptions\n"
    + "\t * @param resourceSet   the default {@link ResourceSet}\n"
    + "\t * @return the created {@link ResourceSet} for models\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected ResourceSet createResourceSetForModel(Object generationKey, Map<String, String> options,\n"
    + "\t\t\tList<Exception> exceptions, ResourceSet resourceSet) {\n"
    + "\t\tfinal ResourceSet resourceSetForModels = AQLUtils.createResourceSetForModels(exceptions, generationKey,\n"
    + "\t\t\t\tresourceSet, options);\n\n"
    + "\t\treturn resourceSetForModels;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Initializes the {@link ResourceSet} for models for standalone use.\n"
    + "\t * \n"
    + "\t * @param resourceSetForModels the {@link ResourceSet} for models\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected void standaloneInitialization(ResourceSet resourceSetForModels) {\n"
    + "\t\t// initialize EPackages\n"
    + "\t\tEcorePackage.eINSTANCE.getName();\n\n"
    + "\t\t// register default XMI resource factory\n"
    + "\t\tresourceSetForModels.getResourceFactoryRegistry().getExtensionToFactoryMap()\n"
    + "\t\t\t\t.put(Resource.Factory.Registry.DEFAULT_EXTENSION, new XMIResourceFactoryImpl());\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Loads {@link Resource} in the given {@link ResourceSet} for models.\n"
    + "\t * \n"
    + "\t * @param resourceSetForModels the {@link ResourceSet} for models\n"
    + "\t * @param resources            the {@link List} of resource names to load\n"
    + "\t * @param monitor              the progress {@link Monitor}, it must consumes\n"
    + "\t *                             the number of resources\n"
    + "\t * @return the {@link List} of loaded {@link Resource}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected List<Resource> loadResources(ResourceSet resourceSetForModels, List<String> resources, Monitor monitor) {\n"
    + "\t\tfinal List<Resource> res = new ArrayList<>();\n\n"
    + "\t\tfor (String resource : resources) {\n"
    + "\t\t\tmonitor.subTask(\"Loading \" + resource);\n"
    + "\t\t\tfinal Resource loaded = resourceSetForModels.getResource(URI.createURI(resource, true), true);\n"
    + "\t\t\tif (loaded != null) {\n"
    + "\t\t\t\tres.add(loaded);\n"
    + "\t\t\t}\n"
    + "\t\t\tmonitor.worked(1);\n"
    + "\t\t\tif (monitor.isCanceled()) {\n"
    + "\t\t\t\tbreak;\n"
    + "\t\t\t}\n"
    + "\t\t}\n\n"
    + "\t\treturn res;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Creates the {@link IQualifiedNameResolver}.\n"
    + "\t * \n"
    + "\t * @return the created {@link IQualifiedNameResolver}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected IQualifiedNameResolver createResolver() {\n"
    + "\t\tfinal IQualifiedNameResolver resolver = new ClassLoaderQualifiedNameResolver(this.getClass().getClassLoader(),\n"
    + "\t\t\t\tAcceleoParser.QUALIFIER_SEPARATOR);\n\n"
    + "\t\treturn resolver;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Creates the {@link IQualifiedNameQueryEnvironment}.\n"
    + "\t * \n"
    + "\t * @param options              the {@link Map} of options\n"
    + "\t * @param resolver             the {@link IQualifiedNameResolver}\n"
    + "\t * @param resourceSetForModels the {@link ResourceSet} for models\n"
    + "\t * @return the created {@link IQualifiedNameQueryEnvironment}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected IQualifiedNameQueryEnvironment createAcceleoQueryEnvironment(Map<String, String> options,\n"
    + "\t\t\tIQualifiedNameResolver resolver, ResourceSet resourceSetForModels) {\n"
    + "\t\tfinal IQualifiedNameQueryEnvironment queryEnvironment = AcceleoUtil.newAcceleoQueryEnvironment(options,\n"
    + "\t\t\t\tresolver, resourceSetForModels, false);\n\n"
    + "\t\treturn queryEnvironment;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Creates the {@link AcceleoEvaluator}\n"
    + "\t * \n"
    + "\t * @param targetURI        the target {@link URI}\n"
    + "\t * @param resolver         the {@link IQualifiedNameResolver}\n"
    + "\t * @param queryEnvironment the {@link IQualifiedNameQueryEnvironment}\n"
    + "\t * @return the created {@link AcceleoEvaluator}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected AcceleoEvaluator createAcceleoEvaluator(URI targetURI, IQualifiedNameResolver resolver,\n"
    + "\t\t\tIQualifiedNameQueryEnvironment queryEnvironment) {\n"
    + "\t\tfinal AcceleoEvaluator evaluator = new AcceleoEvaluator(queryEnvironment.getLookupEngine(),\n"
    + "\t\t\t\tSystem.lineSeparator());\n\n"
    + "\t\t// final Representation profilerModelRepresentation = Representation.TREE;\n"
    + "\t\t// final IProfiler profiler =\n"
    + "\t\t// ProfilerUtils.getProfiler(getModuleQualifiedName(),\n"
    + "\t\t// profilerModelRepresentation, ProfilerPackage.eINSTANCE.getProfilerFactory());\n"
    + "\t\t// final AcceleoEvaluator evaluator = new\n"
    + "\t\t// AcceleoProfilerEvaluator(queryEnvironment.getLookupEngine(),\n"
    + "\t\t// System\n"
    + "\t\t// .lineSeparator(), profiler);\n\n"
    + "\t\tresolver.addLoader(new ModuleLoader(new AcceleoParser(), evaluator));\n"
    + "\t\tresolver.addLoader(new JavaLoader(AcceleoParser.QUALIFIER_SEPARATOR, false));\n\n"
    + "\t\treturn evaluator;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Creates the {@link IAcceleoGenerationStrategy}\n"
    + "\t * \n"
    + "\t * @param resourceSetForModels the {@link ResourceSet} containing loaded models\n"
    + "\t * @return the created {@link IAcceleoGenerationStrategy}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected IAcceleoGenerationStrategy createGenerationStrategy(ResourceSet resourceSetForModels) {\n"
    + "\t\tfinal IAcceleoGenerationStrategy strategy = new DefaultGenerationStrategy(\n"
    + "\t\t\t\tresourceSetForModels.getURIConverter(), new DefaultWriterFactory());\n\n"
    + "\t\treturn strategy;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Before the generation starts.\n"
    + "\t * \n"
    + "\t * @param evaluator            the {@link AcceleoEvaluator}\n"
    + "\t * @param queryEnvironment     the {@link IQualifiedNameQueryEnvironment}\n"
    + "\t * @param module               the {@link Module}\n"
    + "\t * @param resourceSetForModels the {@link ResourceSet} containing loaded models\n"
    + "\t * @param generationStrategy   the {@link IAcceleoGenerationStrategy}\n"
    + "\t * @param destination          destination {@link URI}\n"
    + "\t * @param logURI               the {@link URI} for logging if any,\n"
    + "\t *                             <code>null</code> otherwise\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected void beforeGeneration(AcceleoEvaluator evaluator, IQualifiedNameQueryEnvironment queryEnvironment,\n"
    + "\t\t\tModule module, ResourceSet resourceSetForModels, IAcceleoGenerationStrategy strategy, URI destination,\n"
    + "\t\t\tURI logURI) {\n"
    + "\t\t// this is called before the generation starts\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Prints the diagnostics for the given {@link GenerationResult}.\n"
    + "\t * \n"
    + "\t * @param generationResult the {@link GenerationResult}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected void printDiagnostics(GenerationResult generationResult) {\n"
    + "\t\tif (generationResult.getDiagnostic().getSeverity() > Diagnostic.INFO) {\n"
    + "\t\t\tPrintStream stream;\n"
    + "\t\t\tswitch (generationResult.getDiagnostic().getSeverity()) {\n"
    + "\t\t\tcase Diagnostic.WARNING:\n"
    + "\t\t\t\tstream = System.out;\n"
    + "\t\t\t\tstream.println(\"WARNING\");\n"
    + "\t\t\t\tbreak;\n"
    + "\t\t\tcase Diagnostic.ERROR:\n"
    + "\t\t\t\t// Fall-through\n"
    + "\t\t\tdefault:\n"
    + "\t\t\t\t// Shouldn't happen as we only show warnings and errors\n"
    + "\t\t\t\tstream = System.err;\n"
    + "\t\t\t\tstream.println(\"ERROR\");\n"
    + "\t\t\t\tbreak;\n"
    + "\t\t\t}\n"
    + "\t\t\tprintDiagnostic(stream, generationResult.getDiagnostic(), \"\");\n"
    + "\t\t}\n"
    + "\t\tprintSummary(System.out, generationResult);\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Prints the generation summary.\n"
    + "\t * \n"
    + "\t * @param stream the {@link PrintStream}\n"
    + "\t * @param result the {@link GenerationResult}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprivate void printSummary(PrintStream stream, GenerationResult result) {\n"
    + "\t\tint nbErrors = 0;\n"
    + "\t\tint nbWarnings = 0;\n"
    + "\t\tint nbInfos = 0;\n"
    + "\t\tfor (Diagnostic diagnostic : result.getDiagnostic().getChildren()) {\n"
    + "\t\t\tswitch (diagnostic.getSeverity()) {\n"
    + "\t\t\tcase Diagnostic.ERROR:\n"
    + "\t\t\t\tnbErrors++;\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tcase Diagnostic.WARNING:\n"
    + "\t\t\t\tnbWarnings++;\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tcase Diagnostic.INFO:\n"
    + "\t\t\t\tnbInfos++;\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tdefault:\n"
    + "\t\t\t\tbreak;\n"
    + "\t\t\t}\n"
    + "\t\t}\n\n"
    + "\t\tstream.print(\"Files: \" + result.getGeneratedFiles().size());\n"
    + "\t\tstream.print(\", Lost Files: \" + result.getLostFiles().size());\n"
    + "\t\tstream.print(\", Errors: \" + nbErrors);\n"
    + "\t\tstream.print(\", Warnings: \" + nbWarnings);\n"
    + "\t\tstream.print(\", Infos: \" + nbInfos);\n"
    + "\t\tstream.println(\".\");\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Prints the given {@link Diagnostic} for the given {@link PrintStream}.\n"
    + "\t * \n"
    + "\t * @param stream      the {@link PrintStream}\n"
    + "\t * @param diagnostic  the {@link Diagnostic}\n"
    + "\t * @param indentation the current indentation\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected void printDiagnostic(PrintStream stream, Diagnostic diagnostic, String indentation) {\n"
    + "\t\tString nextIndentation = indentation;\n"
    + "\t\tif (diagnostic.getMessage() != null) {\n"
    + "\t\t\tstream.print(indentation);\n"
    + "\t\t\tswitch (diagnostic.getSeverity()) {\n"
    + "\t\t\tcase Diagnostic.INFO:\n"
    + "\t\t\t\tstream.print(\"INFO \");\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tcase Diagnostic.WARNING:\n"
    + "\t\t\t\tstream.print(\"WARNING \");\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tcase Diagnostic.ERROR:\n"
    + "\t\t\t\tstream.print(\"ERROR \");\n"
    + "\t\t\t\tbreak;\n"
    + "\t\t\t}\n"
    + "\t\t\tif (!diagnostic.getData().isEmpty() && diagnostic.getData().get(0) instanceof ASTNode) {\n"
    + "\t\t\t\tstream.print(AcceleoUtil.getLocation((ASTNode) diagnostic.getData().get(0)));\n"
    + "\t\t\t}\n"
    + "\t\t\tstream.println(\": \" + diagnostic.getMessage().replaceAll(\"\\n"
    + "\", \"\\n"
    + "\" + nextIndentation));\n"
    + "\t\t\tnextIndentation += \"\\t\";\n"
    + "\t\t}\n"
    + "\t\tfor (Diagnostic child : diagnostic.getChildren()) {\n"
    + "\t\t\tprintDiagnostic(stream, child, nextIndentation);\n"
    + "\t\t}\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * After the generation finished.\n"
    + "\t * \n"
    + "\t * @param generationResult the {@link GenerationResult}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected void afterGeneration(GenerationResult generationResult) {\n"
    + "\t\t// this is called after the generation finished\n"
    + "\t}\n\n"
    + "}" | verify-true
get-view "Package Explorer" | get-tree | select "test/META-INF/MANIFEST.MF" | double-click
get-editor test | get-tab-folder | get-tab-item "MANIFEST.MF" | click
get-editor test | get-text-viewer | get-property text | equals "Manifest-Version: 1.0\n"
    + "Bundle-ManifestVersion: 2\n"
    + "Bundle-Name: Test\n"
    + "Bundle-SymbolicName: test\n"
    + "Bundle-Version: 1.0.0.qualifier\n"
    + "Export-Package: test\n"
    + "Require-Bundle: org.eclipse.acceleo.query;bundle-version=\"[8.0.4,9.0.0)\",\n"
    + "  org.eclipse.acceleo.aql;bundle-version=\"[4.1.1,5.0.0)\",\n"
    + "  org.eclipse.acceleo.aql.profiler;bundle-version=\"[4.1.1,5.0.0)\",\n"
    + "  org.antlr.runtime;bundle-version=\"[4.10.1,4.10.2)\",\n"
    + "  org.eclipse.emf.ecore\n"
    + "Automatic-Module-Name: test\n"
    + "Bundle-RequiredExecutionEnvironment: JavaSE-17" | verify-true
get-view "Package Explorer" | get-tree | select "test.ide.ui/META-INF/MANIFEST.MF" | double-click
get-editor "test.ide.ui" | get-tab-folder | get-tab-item "MANIFEST.MF" | click
get-editor "test.ide.ui" | get-text-viewer | get-property text | equals "Manifest-Version: 1.0\n"
    + "Bundle-ManifestVersion: 2\n"
    + "Bundle-Name: test.ide.ui\n"
    + "Bundle-SymbolicName: test.ide.ui;singleton:=true\n"
    + "Bundle-Version: 1.0.0.qualifier\n"
    + "Bundle-ClassPath: .\n"
    + "Bundle-Activator: test.ide.ui.Activator$Implementation\n"
    + "Require-Bundle: org.eclipse.emf.ecore,\n"
    + " org.eclipse.acceleo.aql;bundle-version=\"[4.1.0,5.0.0)\",\n"
    + " org.eclipse.acceleo.aql.profiler;bundle-version=\"[4.1.0,5.0.0)\",\n"
    + " org.eclipse.acceleo.query;bundle-version=\"[8.0.3,9.0.0)\",\n"
    + " org.eclipse.acceleo.query.ide;bundle-version=\"[8.0.3,9.0.0)\",\n"
    + " org.antlr.runtime;bundle-version=\"[4.10.1,4.10.2)\",\n"
    + " org.eclipse.core.resources,\n"
    + " org.eclipse.core.runtime,\n"
    + " test,\n"
    + " org.eclipse.ui,\n"
    + " org.eclipse.acceleo.aql.ide.ui;bundle-version=\"[4.1.0,5.0.0)\"\n"
    + "Bundle-RequiredExecutionEnvironment: JavaSE-11\n"
    + "Automatic-Module-Name: test.ide.ui" | verify-true
get-view "Package Explorer" | get-tree | select "test.ide.ui/src/test.ide.ui/Activator.java" | double-click
get-editor "Activator.java" | get-text-viewer | get-property text | equals "//Start of user code copyright\n\n"
    + "package test.ide.ui;\n\n"
    + "//Start of user code imports\n"
    + "import org.eclipse.core.runtime.IStatus;\n\n"
    + "//End of user code\n\n"
    + "/**\n"
    + " * Plugin's activator class.\n"
    + " * \n"
    + " * @author username\n"
    + " */\n"
    + "public class Activator extends EMFPlugin {\n\n"
    + "\t/**\n"
    + "\t * Plugin's id.\n"
    + "\t */\n"
    + "\tpublic static final String PLUGIN_ID = \"test.ide.ui\"; //$NON-NLS-1$\n\n"
    + "\t/**\n"
    + "\t * The shared instance.\n"
    + "\t */\n"
    + "\tpublic static final Activator INSTANCE = new Activator();\n\n"
    + "\t/**\n"
    + "\t * The implementation plugin for Eclipse.\n"
    + "\t */\n"
    + "\tprivate static Implementation plugin;\n\n"
    + "\t/**\n"
    + "\t * The constructor.\n"
    + "\t */\n"
    + "\tpublic Activator() {\n"
    + "\t\tsuper(new ResourceLocator[] {});\n"
    + "\t}\n\n"
    + "\t@Override\n"
    + "\tpublic ResourceLocator getPluginResourceLocator() {\n"
    + "\t\treturn plugin;\n"
    + "\t}\n\n"
    + "\tpublic static Implementation getPlugin() {\n"
    + "\t\treturn plugin;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Class implementing the EclipsePlugin instance, instanciated when the code is\n"
    + "\t * run in an OSGi context.\n"
    + "\t * \n"
    + "\t * @author cedric\n"
    + "\t */\n"
    + "\tpublic static class Implementation extends EclipsePlugin {\n\n"
    + "\t\t/**\n"
    + "\t\t * Create the Eclipse Implementation.\n"
    + "\t\t */\n"
    + "\t\tpublic Implementation() {\n"
    + "\t\t\tsuper();\n\n"
    + "\t\t\t// Remember the static instance.\n"
    + "\t\t\t//\n"
    + "\t\t\tplugin = this;\n"
    + "\t\t}\n\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Returns the shared instance.\n"
    + "\t *\n"
    + "\t * @return the shared instance.\n"
    + "\t */\n"
    + "\tpublic static Activator getDefault() {\n"
    + "\t\treturn INSTANCE;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Logs the given exception as error or warning.\n"
    + "\t * \n"
    + "\t * @param exception The exception to log.\n"
    + "\t * @param blocker   <code>True</code> if the message must be logged as error,\n"
    + "\t *                  <code>False</code> to log it as a warning.\n"
    + "\t */\n"
    + "\tpublic static void log(Exception exception, boolean blocker) {\n"
    + "\t\tfinal int severity;\n"
    + "\t\tif (blocker) {\n"
    + "\t\t\tseverity = IStatus.ERROR;\n"
    + "\t\t} else {\n"
    + "\t\t\tseverity = IStatus.WARNING;\n"
    + "\t\t}\n"
    + "\t\tActivator.INSTANCE.log(new Status(severity, PLUGIN_ID, exception.getMessage(), exception));\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Puts the given message in the error log view, as error or warning.\n"
    + "\t * \n"
    + "\t * @param message The message to put in the error log view.\n"
    + "\t * @param blocker <code>True</code> if the message must be logged as error,\n"
    + "\t *                <code>False</code> to log it as a warning.\n"
    + "\t */\n"
    + "\tpublic static void log(String message, boolean blocker) {\n"
    + "\t\tint severity = IStatus.WARNING;\n"
    + "\t\tif (blocker) {\n"
    + "\t\t\tseverity = IStatus.ERROR;\n"
    + "\t\t}\n"
    + "\t\tString errorMessage = message;\n"
    + "\t\tif (errorMessage == null || \"\".equals(errorMessage)) { //$NON-NLS-1$\n"
    + "\t\t\terrorMessage = \"Logging null message should never happens.\"; //$NON-NLS-1$\n"
    + "\t\t}\n"
    + "\t\tActivator.INSTANCE.log(new Status(severity, PLUGIN_ID, errorMessage));\n"
    + "\t}\n\n"
    + "}" | verify-true
get-view "Package Explorer" | get-tree | select "test.ide.ui/src/test.ide.ui/TestGeneratorEclipse.java" 
    | select "test.ide.ui/src/test.ide.ui/TestGeneratorEclipse.java" | double-click
get-editor "TestGeneratorEclipse.java" | get-text-viewer | get-property text 
    | equals "//Start of user code copyright\n\n"
    + "package test.ide.ui;\n\n"
    + "//Start of user code imports\n"
    + "import java.io.File;\n\n"
    + "//End of user code\n\n"
    + "/**\n"
    + " * Eclipse launcher for test::test.\n"
    + " * \n"
    + " * @author username\n"
    + " * @generated\n"
    + " */\n"
    + "public class TestGeneratorEclipse extends TestGenerator {\n\n"
    + "\t/**\n"
    + "\t * Opens the dialog to select the target folder.\n"
    + "\t */\n"
    + "\tprivate static final class SelectTargetRunnable implements Runnable {\n\n"
    + "\t\t/**\n"
    + "\t\t * The target folder.\n"
    + "\t\t */\n"
    + "\t\tprivate String target;\n\n"
    + "\t\t@Override\n"
    + "\t\tpublic void run() {\n"
    + "\t\t\tfinal AbstractResourceSelectionDialog dialog = new FolderSelectionDialog(\n"
    + "\t\t\t\t\tPlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell(), \"Select the destination folder\",\n"
    + "\t\t\t\t\t\"\");\n"
    + "\t\t\tfinal int dialogResult = dialog.open();\n"
    + "\t\t\tif ((dialogResult == IDialogConstants.OK_ID) && dialog.getFileName() != null\n"
    + "\t\t\t\t\t&& !dialog.getFileName().isEmpty()) {\n"
    + "\t\t\t\tfinal Path location = new Path(dialog.getFileName());\n"
    + "\t\t\t\tIWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace().getRoot();\n"
    + "\t\t\t\tif (location.segmentCount() == 1) {\n"
    + "\t\t\t\t\ttarget = workspaceRoot.getProject(location.segment(0)).getLocation().toFile().getAbsolutePath();\n"
    + "\t\t\t\t} else {\n"
    + "\t\t\t\t\ttarget = workspaceRoot.getFolder(location).getLocation().toFile().getAbsolutePath();\n"
    + "\t\t\t\t}\n"
    + "\t\t\t} else {\n"
    + "\t\t\t\ttarget = null;\n"
    + "\t\t\t}\n"
    + "\t\t}\n\n"
    + "\t\t/**\n"
    + "\t\t * Gets the target folder.\n"
    + "\t\t * \n"
    + "\t\t * @return the target folder\n"
    + "\t\t */\n"
    + "\t\tpublic String getTarget() {\n"
    + "\t\t\treturn target;\n"
    + "\t\t}\n\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * The selected value.\n"
    + "\t * \n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprivate final List<EObject> values;\n\n"
    + "\t/**\n"
    + "\t * Constructor.\n"
    + "\t * \n"
    + "\t * @param selected the selected {@link IFile}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tpublic TestGeneratorEclipse(IFile selected) {\n"
    + "\t\tsuper(Collections.singletonList(URI.createFileURI(selected.getLocation().toString()).toString()),\n"
    + "\t\t\t\tgetTarget(selected));\n"
    + "\t\tthis.values = null;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Constructor.\n"
    + "\t * \n"
    + "\t * @param selected the selected {@link IFile}\n"
    + "\t * @param target   the target folder of the generation\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tpublic TestGeneratorEclipse(IFile selected, String target) {\n"
    + "\t\tsuper(Collections.singletonList(URI.createFileURI(selected.getLocation().toString()).toString()), target);\n"
    + "\t\tthis.values = null;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Constructor.\n"
    + "\t * \n"
    + "\t * @param selected the selected {@link EPackage}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tpublic TestGeneratorEclipse(EPackage selected) {\n"
    + "\t\tsuper(Collections.emptyList(), getTarget(selected));\n"
    + "\t\tthis.values = Collections.singletonList(selected);\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Constructor.\n"
    + "\t * \n"
    + "\t * @param selected the selected {@link EPackage}\n"
    + "\t * @param target   the target folder of the generation\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tpublic TestGeneratorEclipse(EPackage selected, String target) {\n"
    + "\t\tsuper(Collections.emptyList(), target);\n"
    + "\t\tthis.values = Collections.singletonList(selected);\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\t@Override\n"
    + "\tprotected List<EObject> getValues(IQualifiedNameQueryEnvironment queryEnvironment,\n"
    + "\t\t\tMap<EClass, List<EObject>> valuesCache, TypeLiteral type, ResourceSet resourceSetForModels,\n"
    + "\t\t\tList<Resource> modelResources, Monitor monitor) {\n"
    + "\t\tfinal List<EObject> res;\n\n"
    + "\t\tif (values != null) {\n"
    + "\t\t\tres = values;\n"
    + "\t\t} else {\n"
    + "\t\t\tres = super.getValues(queryEnvironment, valuesCache, type, resourceSetForModels, modelResources, monitor);\n"
    + "\t\t}\n\n"
    + "\t\treturn res;\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\t@Override\n"
    + "\tprotected void standaloneInitialization(ResourceSet resourceSetForModels) {\n"
    + "\t\t// nothing to do here\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\t@Override\n"
    + "\tprotected IQualifiedNameResolver createResolver() {\n"
    + "\t\tfinal String bundleIdentifier = \"test\";\n"
    + "\t\tfinal Bundle bundle = Platform.getBundle(bundleIdentifier);\n"
    + "\t\tif (bundle == null || bundle.getState() == Bundle.UNINSTALLED) {\n"
    + "\t\t\tActivator.getDefault().log(new Status(IStatus.ERROR, getClass(),\n"
    + "\t\t\t\t\t\"The Bundle \" + bundleIdentifier + \" must be available in the target platform.\"));\n"
    + "\t\t}\n"
    + "\t\treturn new OSGiQualifiedNameResolver(bundle, AcceleoParser.QUALIFIER_SEPARATOR);\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Gets the target folder for the selected {@link EPackage} or selected\n"
    + "\t * {@link IFile}.\n"
    + "\t * \n"
    + "\t * @param selected the model {@link EPackage} or selected {@link IFile}\n"
    + "\t * @return the target folder for the selected {@link EPackage} or selected\n"
    + "\t *         {@link IFile}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprivate static String getTarget(Object selected) {\n"
    + "\t\tfinal SelectTargetRunnable runnable = new SelectTargetRunnable();\n"
    + "\t\tDisplay.getDefault().syncExec(runnable);\n\n"
    + "\t\treturn runnable.getTarget();\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\t@Override\n"
    + "\tpublic void generate(Monitor monitor) {\n"
    + "\t\tif (target != null) {\n"
    + "\t\t\tsuper.generate(monitor);\n"
    + "\t\t}\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Prints the diagnostics for the given {@link GenerationResult}.\n"
    + "\t * \n"
    + "\t * @param generationResult the {@link GenerationResult}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected void printDiagnostics(GenerationResult generationResult) {\n"
    + "\t\tif (generationResult.getDiagnostic().getSeverity() > Diagnostic.INFO) {\n"
    + "\t\t\tprintDiagnostic(generationResult.getDiagnostic());\n"
    + "\t\t}\n"
    + "\t\tprintSummary(generationResult);\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Prints the given {@link Diagnostic} for the given {@link PrintStream}.\n"
    + "\t * \n"
    + "\t * @param stream      the {@link PrintStream}\n"
    + "\t * @param diagnostic  the {@link Diagnostic}\n"
    + "\t * @param indentation the current indentation\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected void printDiagnostic(Diagnostic diagnostic) {\n"
    + "\t\tif (diagnostic.getMessage() != null) {\n"
    + "\t\t\tfinal String location;\n"
    + "\t\t\tif (!diagnostic.getData().isEmpty() && diagnostic.getData().get(0) instanceof ASTNode) {\n"
    + "\t\t\t\tlocation = AcceleoUtil.getLocation((ASTNode) diagnostic.getData().get(0)) + \": \";\n"
    + "\t\t\t} else {\n"
    + "\t\t\t\tlocation = \"\";\n"
    + "\t\t\t}\n"
    + "\t\t\tswitch (diagnostic.getSeverity()) {\n"
    + "\t\t\tcase Diagnostic.INFO:\n"
    + "\t\t\t\tActivator.getDefault().log(new Status(IStatus.INFO, diagnostic.getSource(),\n"
    + "\t\t\t\t\t\tlocation + diagnostic.getMessage(), diagnostic.getException()));\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tcase Diagnostic.WARNING:\n"
    + "\t\t\t\tActivator.getDefault().log(new Status(IStatus.WARNING, diagnostic.getSource(),\n"
    + "\t\t\t\t\t\tlocation + diagnostic.getMessage(), diagnostic.getException()));\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tcase Diagnostic.ERROR:\n"
    + "\t\t\t\tActivator.getDefault().log(new Status(IStatus.ERROR, diagnostic.getSource(),\n"
    + "\t\t\t\t\t\tlocation + diagnostic.getMessage(), diagnostic.getException()));\n"
    + "\t\t\t\tbreak;\n"
    + "\t\t\t}\n"
    + "\t\t}\n"
    + "\t\tfor (Diagnostic child : diagnostic.getChildren()) {\n"
    + "\t\t\tprintDiagnostic(child);\n"
    + "\t\t}\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * Prints the summary of the generation.\n"
    + "\t * \n"
    + "\t * @param result the {@link GenerationResult}\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\tprotected void printSummary(GenerationResult result) {\n"
    + "\t\tint nbErrors = 0;\n"
    + "\t\tint nbWarnings = 0;\n"
    + "\t\tint nbInfos = 0;\n"
    + "\t\tfor (Diagnostic diagnostic : result.getDiagnostic().getChildren()) {\n"
    + "\t\t\tswitch (diagnostic.getSeverity()) {\n"
    + "\t\t\tcase Diagnostic.ERROR:\n"
    + "\t\t\t\tnbErrors++;\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tcase Diagnostic.WARNING:\n"
    + "\t\t\t\tnbWarnings++;\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tcase Diagnostic.INFO:\n"
    + "\t\t\t\tnbInfos++;\n"
    + "\t\t\t\tbreak;\n\n"
    + "\t\t\tdefault:\n"
    + "\t\t\t\tbreak;\n"
    + "\t\t\t}\n"
    + "\t\t}\n\n"
    + "\t\tfinal String message = \"Files: \" + result.getGeneratedFiles().size() + \", Lost Files: \"\n"
    + "\t\t\t\t+ result.getLostFiles().size() + \", Errors: \" + nbErrors + \", Warnings: \" + nbWarnings + \", Infos: \"\n"
    + "\t\t\t\t+ nbInfos + \".\";\n"
    + "\t\tActivator.getDefault().log(new Status(IStatus.INFO, getClass(), message));\n"
    + "\t}\n\n"
    + "\t/**\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\t@Override\n"
    + "\tprotected void afterGeneration(GenerationResult generationResult) {\n"
    + "\t\tsuper.afterGeneration(generationResult);\n\n"
    + "\t\t// refresh if the generated files are in the workspace\n"
    + "\t\tfinal File targetFolder = new File(target);\n"
    + "\t\tfinal IContainer targetWorkspaceContainer = ResourcesPlugin.getWorkspace().getRoot()\n"
    + "\t\t\t\t.getContainerForLocation(new Path(targetFolder.getAbsolutePath()));\n"
    + "\t\tif (targetWorkspaceContainer != null) {\n"
    + "\t\t\ttry {\n"
    + "\t\t\t\ttargetWorkspaceContainer.refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor());\n"
    + "\t\t\t} catch (CoreException e) {\n"
    + "\t\t\t\tActivator.getDefault().log(new Status(IStatus.ERROR, Activator.PLUGIN_ID,\n"
    + "\t\t\t\t\t\t\"could not refresh \" + targetWorkspaceContainer.getFullPath(), e));\n"
    + "\t\t\t}\n"
    + "\t\t}\n"
    + "\t}\n\n"
    + "}" | verify-true
get-view "Package Explorer" | get-tree | select "test.ide.ui/src/test.ide.ui.handlers/TestGeneratorHandler.java" 
    | double-click
get-editor "TestGeneratorHandler.java" | get-text-viewer | get-property text 
    | equals "//Start of user code copyright\n\n"
    + "package test.ide.ui.handlers;\n\n"
    + "//Start of user code imports\n\n"
    + "import java.lang.reflect.InvocationTargetException;\n\n"
    + "//End of user code\n\n"
    + "/**\n"
    + " * Command handler for test::test.\n"
    + " * \n"
    + " * @author username\n"
    + " * @generated\n"
    + " */\n"
    + "public class TestGeneratorHandler extends AbstractHandler {\n\n"
    + "\t/**\n"
    + "\t * @generated\n"
    + "\t */\n"
    + "\t@Override\n"
    + "\tpublic Object execute(ExecutionEvent event) throws ExecutionException {\n"
    + "\t\tfinal IStructuredSelection selection = HandlerUtil.getCurrentStructuredSelection(event);\n\n"
    + "\t\tfinal IRunnableWithProgress generateRunnable = new IRunnableWithProgress() {\n\n"
    + "\t\t\t@Override\n"
    + "\t\t\tpublic void run(IProgressMonitor monitor) throws InvocationTargetException, InterruptedException {\n"
    + "\t\t\t\tfinal Iterator<?> it = selection.iterator();\n"
    + "\t\t\t\tfinal List<Object> selectedList = new ArrayList<>();\n"
    + "\t\t\t\twhile (it.hasNext()) {\n"
    + "\t\t\t\t\tselectedList.add(it.next());\n"
    + "\t\t\t\t}\n"
    + "\t\t\t\tfinal SubMonitor subMonitor = SubMonitor.convert(monitor, selectedList.size());\n"
    + "\t\t\t\tfor (Object selected : selectedList) {\n"
    + "\t\t\t\t\tfinal Monitor childMonitor = BasicMonitor.toMonitor(subMonitor.split(1));\n"
    + "\t\t\t\t\tfinal TestGeneratorEclipse generator;\n"
    + "\t\t\t\t\ttry {\n"
    + "\t\t\t\t\t\tif (selected instanceof EPackage) {\n"
    + "\t\t\t\t\t\t\tgenerator = new TestGeneratorEclipse((EPackage) selected);\n"
    + "\t\t\t\t\t\t\tgenerator.generate(childMonitor);\n"
    + "\t\t\t\t\t\t} else if (selected instanceof IFile) {\n"
    + "\t\t\t\t\t\t\tgenerator = new TestGeneratorEclipse((IFile) selected);\n"
    + "\t\t\t\t\t\t\tgenerator.generate(childMonitor);\n"
    + "\t\t\t\t\t\t}\n"
    + "\t\t\t\t\t} finally {\n"
    + "\t\t\t\t\t\tchildMonitor.done();\n"
    + "\t\t\t\t\t}\n"
    + "\t\t\t\t\tif (monitor.isCanceled()) {\n"
    + "\t\t\t\t\t\tbreak;\n"
    + "\t\t\t\t\t}\n"
    + "\t\t\t\t}\n"
    + "\t\t\t}\n"
    + "\t\t};\n\n"
    + "\t\ttry {\n"
    + "\t\t\tPlatformUI.getWorkbench().getProgressService().run(true, true, generateRunnable);\n"
    + "\t\t} catch (InvocationTargetException e) {\n"
    + "\t\t\tActivator.getDefault()\n"
    + "\t\t\t\t\t.log(new Status(IStatus.ERROR, getClass(), \"Couldn't generate.\", e.getTargetException()));\n"
    + "\t\t} catch (InterruptedException e) {\n"
    + "\t\t\tActivator.getDefault().log(new Status(IStatus.ERROR, getClass(), \"Couldn't generate.\", e));\n"
    + "\t\t}\n\n"
    + "\t\treturn null;\n"
    + "\t}\n\n"
    + "}" | verify-true
------=_.content-0a7243a0-75d3-3d5f-9791-539de0e5b7ac--
